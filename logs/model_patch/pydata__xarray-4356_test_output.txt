>>>>> Start Test Output
+ export PYTHONPATH=/testbed:
+ PYTHONPATH=/testbed:
+ echo PYTHONPATH=/testbed:
PYTHONPATH=/testbed:
+ pytest -rA xarray/tests/test_duck_array_ops.py
============================= test session starts ==============================
platform linux -- Python 3.10.19, pytest-7.4.0, pluggy-1.6.0
rootdir: /testbed
configfile: setup.cfg
plugins: hypothesis-6.148.7, xdist-3.8.0, cov-7.0.0, env-1.2.0
collected 820 items

xarray/tests/test_duck_array_ops.py .................................... [  4%]
..ss..............ss..............ss......ss......ss..............ss.... [ 13%]
..................................................ss......ss............ [ 21%]
..................ss..............ss..............ss......ss......ss.... [ 30%]
..........ss......................................................ss.... [ 39%]
..ss................ssssssssss..........ssssssssss..........ssssssssss.. [ 48%]
........ssssssssss..........ssssss..............ssssss..............ssss [ 57%]
ss..............ssssss..............sssssssssss.s.s.s.s.sssssssssss.s.s. [ 65%]
s.s.sssssssssss.s.s.s.s.sssssssssss.s.s.s.s.sssssss.s.s.s.s.s.s.sssssss. [ 74%]
s.s.s.s.s.s.sssssss.s.s.s.s.s.s.sssssss.s.s.s.s.s.s..................... [ 83%]
.....FFFFFFFFFFFFFFFF................FFFFFFFFFFFFFFFF................FFF [ 92%]
FFFFFFFFFFFFFF..................................................         [100%]

=================================== FAILURES ===================================
____________________ test_min_count[None-sum-False-float-1] ____________________

dim_num = 1, dtype = <class 'float'>, dask = False, func = 'sum', aggdim = None

    @pytest.mark.parametrize("dim_num", [1, 2])
    @pytest.mark.parametrize("dtype", [float, int, np.float32, np.bool_])
    @pytest.mark.parametrize("dask", [False, True])
    @pytest.mark.parametrize("func", ["sum", "prod"])
    @pytest.mark.parametrize("aggdim", [None, "x"])
    def test_min_count(dim_num, dtype, dask, func, aggdim):
        if dask and not has_dask:
            pytest.skip("requires dask")
    
        da = construct_dataarray(dim_num, dtype, contains_nan=True, dask=dask)
        min_count = 3
    
>       actual = getattr(da, func)(dim=aggdim, skipna=True, min_count=min_count)

xarray/tests/test_duck_array_ops.py:592: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/common.py:46: in wrapped_func
    return self.reduce(func, dim, axis, skipna=skipna, **kwargs)
xarray/core/dataarray.py:2347: in reduce
    var = self.variable.reduce(func, dim, axis, keep_attrs, keepdims, **kwargs)
xarray/core/variable.py:1642: in reduce
    data = func(input_data, **kwargs)
xarray/core/duck_array_ops.py:335: in f
    return func(values, axis=axis, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = array([ 1.76405235,  0.40015721,  0.        ,  0.        ,  1.86755799,
       -0.97727788,  0.95008842, -0.15135721,  0.        ,  0.4105985 ,
        0.14404357,  1.45427351,  0.76103773,  0.12167502,  0.44386323,
        0.33367433])
axis = None, dtype = None, out = None, min_count = 3

    def nansum(a, axis=None, dtype=None, out=None, min_count=None):
        a, mask = _replace_nan(a, 0)
        result = _dask_or_eager_func("sum")(a, axis=axis, dtype=dtype)
        if min_count is not None:
            if isinstance(axis, (tuple, list)):
                axis = tuple(range(len(a.shape))) if axis is None else axis
                valid_elements = np.take(a.shape, axis).prod()
            else:
>               valid_elements = a.shape[axis]
E               TypeError: tuple indices must be integers or slices, not NoneType

xarray/core/nanops.py:119: TypeError
____________________ test_min_count[None-sum-False-float-2] ____________________

dim_num = 2, dtype = <class 'float'>, dask = False, func = 'sum', aggdim = None

    @pytest.mark.parametrize("dim_num", [1, 2])
    @pytest.mark.parametrize("dtype", [float, int, np.float32, np.bool_])
    @pytest.mark.parametrize("dask", [False, True])
    @pytest.mark.parametrize("func", ["sum", "prod"])
    @pytest.mark.parametrize("aggdim", [None, "x"])
    def test_min_count(dim_num, dtype, dask, func, aggdim):
        if dask and not has_dask:
            pytest.skip("requires dask")
    
        da = construct_dataarray(dim_num, dtype, contains_nan=True, dask=dask)
        min_count = 3
    
>       actual = getattr(da, func)(dim=aggdim, skipna=True, min_count=min_count)

xarray/tests/test_duck_array_ops.py:592: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/common.py:46: in wrapped_func
    return self.reduce(func, dim, axis, skipna=skipna, **kwargs)
xarray/core/dataarray.py:2347: in reduce
    var = self.variable.reduce(func, dim, axis, keep_attrs, keepdims, **kwargs)
xarray/core/variable.py:1642: in reduce
    data = func(input_data, **kwargs)
xarray/core/duck_array_ops.py:335: in f
    return func(values, axis=axis, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = array([[ 0.        ,  0.40015721,  0.97873798,  0.        ,  1.86755799,
         0.        ,  0.95008842, -0.15135721...     [ 0.37642553, -1.09940079,  0.29823817,  1.3263859 , -0.69456786,
        -0.14963454, -0.43515355,  0.        ]])
axis = None, dtype = None, out = None, min_count = 3

    def nansum(a, axis=None, dtype=None, out=None, min_count=None):
        a, mask = _replace_nan(a, 0)
        result = _dask_or_eager_func("sum")(a, axis=axis, dtype=dtype)
        if min_count is not None:
            if isinstance(axis, (tuple, list)):
                axis = tuple(range(len(a.shape))) if axis is None else axis
                valid_elements = np.take(a.shape, axis).prod()
            else:
>               valid_elements = a.shape[axis]
E               TypeError: tuple indices must be integers or slices, not NoneType

xarray/core/nanops.py:119: TypeError
_____________________ test_min_count[None-sum-False-int-1] _____________________

dim_num = 1, dtype = <class 'int'>, dask = False, func = 'sum', aggdim = None

    @pytest.mark.parametrize("dim_num", [1, 2])
    @pytest.mark.parametrize("dtype", [float, int, np.float32, np.bool_])
    @pytest.mark.parametrize("dask", [False, True])
    @pytest.mark.parametrize("func", ["sum", "prod"])
    @pytest.mark.parametrize("aggdim", [None, "x"])
    def test_min_count(dim_num, dtype, dask, func, aggdim):
        if dask and not has_dask:
            pytest.skip("requires dask")
    
        da = construct_dataarray(dim_num, dtype, contains_nan=True, dask=dask)
        min_count = 3
    
>       actual = getattr(da, func)(dim=aggdim, skipna=True, min_count=min_count)

xarray/tests/test_duck_array_ops.py:592: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/common.py:46: in wrapped_func
    return self.reduce(func, dim, axis, skipna=skipna, **kwargs)
xarray/core/dataarray.py:2347: in reduce
    var = self.variable.reduce(func, dim, axis, keep_attrs, keepdims, **kwargs)
xarray/core/variable.py:1642: in reduce
    data = func(input_data, **kwargs)
xarray/core/duck_array_ops.py:335: in f
    return func(values, axis=axis, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = array([5., 0., 3., 3., 7., 9., 3., 0., 2., 4., 7., 6., 8., 8., 0., 6.])
axis = None, dtype = None, out = None, min_count = 3

    def nansum(a, axis=None, dtype=None, out=None, min_count=None):
        a, mask = _replace_nan(a, 0)
        result = _dask_or_eager_func("sum")(a, axis=axis, dtype=dtype)
        if min_count is not None:
            if isinstance(axis, (tuple, list)):
                axis = tuple(range(len(a.shape))) if axis is None else axis
                valid_elements = np.take(a.shape, axis).prod()
            else:
>               valid_elements = a.shape[axis]
E               TypeError: tuple indices must be integers or slices, not NoneType

xarray/core/nanops.py:119: TypeError
_____________________ test_min_count[None-sum-False-int-2] _____________________

dim_num = 2, dtype = <class 'int'>, dask = False, func = 'sum', aggdim = None

    @pytest.mark.parametrize("dim_num", [1, 2])
    @pytest.mark.parametrize("dtype", [float, int, np.float32, np.bool_])
    @pytest.mark.parametrize("dask", [False, True])
    @pytest.mark.parametrize("func", ["sum", "prod"])
    @pytest.mark.parametrize("aggdim", [None, "x"])
    def test_min_count(dim_num, dtype, dask, func, aggdim):
        if dask and not has_dask:
            pytest.skip("requires dask")
    
        da = construct_dataarray(dim_num, dtype, contains_nan=True, dask=dask)
        min_count = 3
    
>       actual = getattr(da, func)(dim=aggdim, skipna=True, min_count=min_count)

xarray/tests/test_duck_array_ops.py:592: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/common.py:46: in wrapped_func
    return self.reduce(func, dim, axis, skipna=skipna, **kwargs)
xarray/core/dataarray.py:2347: in reduce
    var = self.variable.reduce(func, dim, axis, keep_attrs, keepdims, **kwargs)
xarray/core/variable.py:1642: in reduce
    data = func(input_data, **kwargs)
xarray/core/duck_array_ops.py:335: in f
    return func(values, axis=axis, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = array([[0., 0., 0., 0., 7., 9., 3., 5.],
       [2., 4., 7., 6., 8., 0., 1., 6.],
       [7., 7., 8., 0., 5., 9., 8., ...   [0., 5., 9., 0., 2., 7., 2., 9.],
       [0., 3., 3., 0., 3., 4., 1., 2.],
       [9., 1., 4., 6., 8., 0., 3., 0.]])
axis = None, dtype = None, out = None, min_count = 3

    def nansum(a, axis=None, dtype=None, out=None, min_count=None):
        a, mask = _replace_nan(a, 0)
        result = _dask_or_eager_func("sum")(a, axis=axis, dtype=dtype)
        if min_count is not None:
            if isinstance(axis, (tuple, list)):
                axis = tuple(range(len(a.shape))) if axis is None else axis
                valid_elements = np.take(a.shape, axis).prod()
            else:
>               valid_elements = a.shape[axis]
E               TypeError: tuple indices must be integers or slices, not NoneType

xarray/core/nanops.py:119: TypeError
___________________ test_min_count[None-sum-False-float32-1] ___________________

dim_num = 1, dtype = <class 'numpy.float32'>, dask = False, func = 'sum'
aggdim = None

    @pytest.mark.parametrize("dim_num", [1, 2])
    @pytest.mark.parametrize("dtype", [float, int, np.float32, np.bool_])
    @pytest.mark.parametrize("dask", [False, True])
    @pytest.mark.parametrize("func", ["sum", "prod"])
    @pytest.mark.parametrize("aggdim", [None, "x"])
    def test_min_count(dim_num, dtype, dask, func, aggdim):
        if dask and not has_dask:
            pytest.skip("requires dask")
    
        da = construct_dataarray(dim_num, dtype, contains_nan=True, dask=dask)
        min_count = 3
    
>       actual = getattr(da, func)(dim=aggdim, skipna=True, min_count=min_count)

xarray/tests/test_duck_array_ops.py:592: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/common.py:46: in wrapped_func
    return self.reduce(func, dim, axis, skipna=skipna, **kwargs)
xarray/core/dataarray.py:2347: in reduce
    var = self.variable.reduce(func, dim, axis, keep_attrs, keepdims, **kwargs)
xarray/core/variable.py:1642: in reduce
    data = func(input_data, **kwargs)
xarray/core/duck_array_ops.py:335: in f
    return func(values, axis=axis, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = array([ 1.7640524 ,  0.4001572 ,  0.        ,  0.        ,  1.867558  ,
       -0.9772779 ,  0.95008844, -0.1513572 , ...0.41059852,
        0.14404356,  1.4542735 ,  0.7610377 ,  0.12167501,  0.44386324,
        0.33367434], dtype=float32)
axis = None, dtype = None, out = None, min_count = 3

    def nansum(a, axis=None, dtype=None, out=None, min_count=None):
        a, mask = _replace_nan(a, 0)
        result = _dask_or_eager_func("sum")(a, axis=axis, dtype=dtype)
        if min_count is not None:
            if isinstance(axis, (tuple, list)):
                axis = tuple(range(len(a.shape))) if axis is None else axis
                valid_elements = np.take(a.shape, axis).prod()
            else:
>               valid_elements = a.shape[axis]
E               TypeError: tuple indices must be integers or slices, not NoneType

xarray/core/nanops.py:119: TypeError
___________________ test_min_count[None-sum-False-float32-2] ___________________

dim_num = 2, dtype = <class 'numpy.float32'>, dask = False, func = 'sum'
aggdim = None

    @pytest.mark.parametrize("dim_num", [1, 2])
    @pytest.mark.parametrize("dtype", [float, int, np.float32, np.bool_])
    @pytest.mark.parametrize("dask", [False, True])
    @pytest.mark.parametrize("func", ["sum", "prod"])
    @pytest.mark.parametrize("aggdim", [None, "x"])
    def test_min_count(dim_num, dtype, dask, func, aggdim):
        if dask and not has_dask:
            pytest.skip("requires dask")
    
        da = construct_dataarray(dim_num, dtype, contains_nan=True, dask=dask)
        min_count = 3
    
>       actual = getattr(da, func)(dim=aggdim, skipna=True, min_count=min_count)

xarray/tests/test_duck_array_ops.py:592: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/common.py:46: in wrapped_func
    return self.reduce(func, dim, axis, skipna=skipna, **kwargs)
xarray/core/dataarray.py:2347: in reduce
    var = self.variable.reduce(func, dim, axis, keep_attrs, keepdims, **kwargs)
xarray/core/variable.py:1642: in reduce
    data = func(input_data, **kwargs)
xarray/core/duck_array_ops.py:335: in f
    return func(values, axis=axis, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = array([[ 0.        ,  0.4001572 ,  0.978738  ,  0.        ,  1.867558  ,
         0.        ,  0.95008844, -0.1513572 ...53, -1.0994008 ,  0.2982382 ,  1.3263859 , -0.69456786,
        -0.14963454, -0.43515354,  0.        ]], dtype=float32)
axis = None, dtype = None, out = None, min_count = 3

    def nansum(a, axis=None, dtype=None, out=None, min_count=None):
        a, mask = _replace_nan(a, 0)
        result = _dask_or_eager_func("sum")(a, axis=axis, dtype=dtype)
        if min_count is not None:
            if isinstance(axis, (tuple, list)):
                axis = tuple(range(len(a.shape))) if axis is None else axis
                valid_elements = np.take(a.shape, axis).prod()
            else:
>               valid_elements = a.shape[axis]
E               TypeError: tuple indices must be integers or slices, not NoneType

xarray/core/nanops.py:119: TypeError
____________________ test_min_count[None-sum-False-bool_-1] ____________________

dim_num = 1, dtype = <class 'numpy.bool_'>, dask = False, func = 'sum'
aggdim = None

    @pytest.mark.parametrize("dim_num", [1, 2])
    @pytest.mark.parametrize("dtype", [float, int, np.float32, np.bool_])
    @pytest.mark.parametrize("dask", [False, True])
    @pytest.mark.parametrize("func", ["sum", "prod"])
    @pytest.mark.parametrize("aggdim", [None, "x"])
    def test_min_count(dim_num, dtype, dask, func, aggdim):
        if dask and not has_dask:
            pytest.skip("requires dask")
    
        da = construct_dataarray(dim_num, dtype, contains_nan=True, dask=dask)
        min_count = 3
    
>       actual = getattr(da, func)(dim=aggdim, skipna=True, min_count=min_count)

xarray/tests/test_duck_array_ops.py:592: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/common.py:46: in wrapped_func
    return self.reduce(func, dim, axis, skipna=skipna, **kwargs)
xarray/core/dataarray.py:2347: in reduce
    var = self.variable.reduce(func, dim, axis, keep_attrs, keepdims, **kwargs)
xarray/core/variable.py:1642: in reduce
    data = func(input_data, **kwargs)
xarray/core/duck_array_ops.py:335: in f
    return func(values, axis=axis, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = array([False, False, False, False, False, 0, False, False, False, False,
       False, False, 0, False, False, 0], dtype=object)
axis = None, dtype = None, out = None, min_count = 3

    def nansum(a, axis=None, dtype=None, out=None, min_count=None):
        a, mask = _replace_nan(a, 0)
        result = _dask_or_eager_func("sum")(a, axis=axis, dtype=dtype)
        if min_count is not None:
            if isinstance(axis, (tuple, list)):
                axis = tuple(range(len(a.shape))) if axis is None else axis
                valid_elements = np.take(a.shape, axis).prod()
            else:
>               valid_elements = a.shape[axis]
E               TypeError: tuple indices must be integers or slices, not NoneType

xarray/core/nanops.py:119: TypeError
____________________ test_min_count[None-sum-False-bool_-2] ____________________

dim_num = 2, dtype = <class 'numpy.bool_'>, dask = False, func = 'sum'
aggdim = None

    @pytest.mark.parametrize("dim_num", [1, 2])
    @pytest.mark.parametrize("dtype", [float, int, np.float32, np.bool_])
    @pytest.mark.parametrize("dask", [False, True])
    @pytest.mark.parametrize("func", ["sum", "prod"])
    @pytest.mark.parametrize("aggdim", [None, "x"])
    def test_min_count(dim_num, dtype, dask, func, aggdim):
        if dask and not has_dask:
            pytest.skip("requires dask")
    
        da = construct_dataarray(dim_num, dtype, contains_nan=True, dask=dask)
        min_count = 3
    
>       actual = getattr(da, func)(dim=aggdim, skipna=True, min_count=min_count)

xarray/tests/test_duck_array_ops.py:592: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/common.py:46: in wrapped_func
    return self.reduce(func, dim, axis, skipna=skipna, **kwargs)
xarray/core/dataarray.py:2347: in reduce
    var = self.variable.reduce(func, dim, axis, keep_attrs, keepdims, **kwargs)
xarray/core/variable.py:1642: in reduce
    data = func(input_data, **kwargs)
xarray/core/duck_array_ops.py:335: in f
    return func(values, axis=axis, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = array([[False, False, False, False, False, False, False, False],
       [False, 0, False, False, 0, False, False, Fals..., False, 0, False, False, 0, False, False],
       [False, False, False, 0, False, False, False, False]], dtype=object)
axis = None, dtype = None, out = None, min_count = 3

    def nansum(a, axis=None, dtype=None, out=None, min_count=None):
        a, mask = _replace_nan(a, 0)
        result = _dask_or_eager_func("sum")(a, axis=axis, dtype=dtype)
        if min_count is not None:
            if isinstance(axis, (tuple, list)):
                axis = tuple(range(len(a.shape))) if axis is None else axis
                valid_elements = np.take(a.shape, axis).prod()
            else:
>               valid_elements = a.shape[axis]
E               TypeError: tuple indices must be integers or slices, not NoneType

xarray/core/nanops.py:119: TypeError
____________________ test_min_count[None-sum-True-float-1] _____________________

dim_num = 1, dtype = <class 'float'>, dask = True, func = 'sum', aggdim = None

    @pytest.mark.parametrize("dim_num", [1, 2])
    @pytest.mark.parametrize("dtype", [float, int, np.float32, np.bool_])
    @pytest.mark.parametrize("dask", [False, True])
    @pytest.mark.parametrize("func", ["sum", "prod"])
    @pytest.mark.parametrize("aggdim", [None, "x"])
    def test_min_count(dim_num, dtype, dask, func, aggdim):
        if dask and not has_dask:
            pytest.skip("requires dask")
    
        da = construct_dataarray(dim_num, dtype, contains_nan=True, dask=dask)
        min_count = 3
    
>       actual = getattr(da, func)(dim=aggdim, skipna=True, min_count=min_count)

xarray/tests/test_duck_array_ops.py:592: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/common.py:46: in wrapped_func
    return self.reduce(func, dim, axis, skipna=skipna, **kwargs)
xarray/core/dataarray.py:2347: in reduce
    var = self.variable.reduce(func, dim, axis, keep_attrs, keepdims, **kwargs)
xarray/core/variable.py:1642: in reduce
    data = func(input_data, **kwargs)
xarray/core/duck_array_ops.py:335: in f
    return func(values, axis=axis, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = dask.array<where, shape=(16,), dtype=float64, chunksize=(4,), chunktype=numpy.ndarray>
axis = None, dtype = None, out = None, min_count = 3

    def nansum(a, axis=None, dtype=None, out=None, min_count=None):
        a, mask = _replace_nan(a, 0)
        result = _dask_or_eager_func("sum")(a, axis=axis, dtype=dtype)
        if min_count is not None:
            if isinstance(axis, (tuple, list)):
                axis = tuple(range(len(a.shape))) if axis is None else axis
                valid_elements = np.take(a.shape, axis).prod()
            else:
>               valid_elements = a.shape[axis]
E               TypeError: tuple indices must be integers or slices, not NoneType

xarray/core/nanops.py:119: TypeError
____________________ test_min_count[None-sum-True-float-2] _____________________

dim_num = 2, dtype = <class 'float'>, dask = True, func = 'sum', aggdim = None

    @pytest.mark.parametrize("dim_num", [1, 2])
    @pytest.mark.parametrize("dtype", [float, int, np.float32, np.bool_])
    @pytest.mark.parametrize("dask", [False, True])
    @pytest.mark.parametrize("func", ["sum", "prod"])
    @pytest.mark.parametrize("aggdim", [None, "x"])
    def test_min_count(dim_num, dtype, dask, func, aggdim):
        if dask and not has_dask:
            pytest.skip("requires dask")
    
        da = construct_dataarray(dim_num, dtype, contains_nan=True, dask=dask)
        min_count = 3
    
>       actual = getattr(da, func)(dim=aggdim, skipna=True, min_count=min_count)

xarray/tests/test_duck_array_ops.py:592: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/common.py:46: in wrapped_func
    return self.reduce(func, dim, axis, skipna=skipna, **kwargs)
xarray/core/dataarray.py:2347: in reduce
    var = self.variable.reduce(func, dim, axis, keep_attrs, keepdims, **kwargs)
xarray/core/variable.py:1642: in reduce
    data = func(input_data, **kwargs)
xarray/core/duck_array_ops.py:335: in f
    return func(values, axis=axis, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = dask.array<where, shape=(16, 8), dtype=float64, chunksize=(4, 4), chunktype=numpy.ndarray>
axis = None, dtype = None, out = None, min_count = 3

    def nansum(a, axis=None, dtype=None, out=None, min_count=None):
        a, mask = _replace_nan(a, 0)
        result = _dask_or_eager_func("sum")(a, axis=axis, dtype=dtype)
        if min_count is not None:
            if isinstance(axis, (tuple, list)):
                axis = tuple(range(len(a.shape))) if axis is None else axis
                valid_elements = np.take(a.shape, axis).prod()
            else:
>               valid_elements = a.shape[axis]
E               TypeError: tuple indices must be integers or slices, not NoneType

xarray/core/nanops.py:119: TypeError
_____________________ test_min_count[None-sum-True-int-1] ______________________

dim_num = 1, dtype = <class 'int'>, dask = True, func = 'sum', aggdim = None

    @pytest.mark.parametrize("dim_num", [1, 2])
    @pytest.mark.parametrize("dtype", [float, int, np.float32, np.bool_])
    @pytest.mark.parametrize("dask", [False, True])
    @pytest.mark.parametrize("func", ["sum", "prod"])
    @pytest.mark.parametrize("aggdim", [None, "x"])
    def test_min_count(dim_num, dtype, dask, func, aggdim):
        if dask and not has_dask:
            pytest.skip("requires dask")
    
        da = construct_dataarray(dim_num, dtype, contains_nan=True, dask=dask)
        min_count = 3
    
>       actual = getattr(da, func)(dim=aggdim, skipna=True, min_count=min_count)

xarray/tests/test_duck_array_ops.py:592: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/common.py:46: in wrapped_func
    return self.reduce(func, dim, axis, skipna=skipna, **kwargs)
xarray/core/dataarray.py:2347: in reduce
    var = self.variable.reduce(func, dim, axis, keep_attrs, keepdims, **kwargs)
xarray/core/variable.py:1642: in reduce
    data = func(input_data, **kwargs)
xarray/core/duck_array_ops.py:335: in f
    return func(values, axis=axis, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = dask.array<where, shape=(16,), dtype=float64, chunksize=(4,), chunktype=numpy.ndarray>
axis = None, dtype = None, out = None, min_count = 3

    def nansum(a, axis=None, dtype=None, out=None, min_count=None):
        a, mask = _replace_nan(a, 0)
        result = _dask_or_eager_func("sum")(a, axis=axis, dtype=dtype)
        if min_count is not None:
            if isinstance(axis, (tuple, list)):
                axis = tuple(range(len(a.shape))) if axis is None else axis
                valid_elements = np.take(a.shape, axis).prod()
            else:
>               valid_elements = a.shape[axis]
E               TypeError: tuple indices must be integers or slices, not NoneType

xarray/core/nanops.py:119: TypeError
_____________________ test_min_count[None-sum-True-int-2] ______________________

dim_num = 2, dtype = <class 'int'>, dask = True, func = 'sum', aggdim = None

    @pytest.mark.parametrize("dim_num", [1, 2])
    @pytest.mark.parametrize("dtype", [float, int, np.float32, np.bool_])
    @pytest.mark.parametrize("dask", [False, True])
    @pytest.mark.parametrize("func", ["sum", "prod"])
    @pytest.mark.parametrize("aggdim", [None, "x"])
    def test_min_count(dim_num, dtype, dask, func, aggdim):
        if dask and not has_dask:
            pytest.skip("requires dask")
    
        da = construct_dataarray(dim_num, dtype, contains_nan=True, dask=dask)
        min_count = 3
    
>       actual = getattr(da, func)(dim=aggdim, skipna=True, min_count=min_count)

xarray/tests/test_duck_array_ops.py:592: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/common.py:46: in wrapped_func
    return self.reduce(func, dim, axis, skipna=skipna, **kwargs)
xarray/core/dataarray.py:2347: in reduce
    var = self.variable.reduce(func, dim, axis, keep_attrs, keepdims, **kwargs)
xarray/core/variable.py:1642: in reduce
    data = func(input_data, **kwargs)
xarray/core/duck_array_ops.py:335: in f
    return func(values, axis=axis, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = dask.array<where, shape=(16, 8), dtype=float64, chunksize=(4, 4), chunktype=numpy.ndarray>
axis = None, dtype = None, out = None, min_count = 3

    def nansum(a, axis=None, dtype=None, out=None, min_count=None):
        a, mask = _replace_nan(a, 0)
        result = _dask_or_eager_func("sum")(a, axis=axis, dtype=dtype)
        if min_count is not None:
            if isinstance(axis, (tuple, list)):
                axis = tuple(range(len(a.shape))) if axis is None else axis
                valid_elements = np.take(a.shape, axis).prod()
            else:
>               valid_elements = a.shape[axis]
E               TypeError: tuple indices must be integers or slices, not NoneType

xarray/core/nanops.py:119: TypeError
___________________ test_min_count[None-sum-True-float32-1] ____________________

dim_num = 1, dtype = <class 'numpy.float32'>, dask = True, func = 'sum'
aggdim = None

    @pytest.mark.parametrize("dim_num", [1, 2])
    @pytest.mark.parametrize("dtype", [float, int, np.float32, np.bool_])
    @pytest.mark.parametrize("dask", [False, True])
    @pytest.mark.parametrize("func", ["sum", "prod"])
    @pytest.mark.parametrize("aggdim", [None, "x"])
    def test_min_count(dim_num, dtype, dask, func, aggdim):
        if dask and not has_dask:
            pytest.skip("requires dask")
    
        da = construct_dataarray(dim_num, dtype, contains_nan=True, dask=dask)
        min_count = 3
    
>       actual = getattr(da, func)(dim=aggdim, skipna=True, min_count=min_count)

xarray/tests/test_duck_array_ops.py:592: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/common.py:46: in wrapped_func
    return self.reduce(func, dim, axis, skipna=skipna, **kwargs)
xarray/core/dataarray.py:2347: in reduce
    var = self.variable.reduce(func, dim, axis, keep_attrs, keepdims, **kwargs)
xarray/core/variable.py:1642: in reduce
    data = func(input_data, **kwargs)
xarray/core/duck_array_ops.py:335: in f
    return func(values, axis=axis, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = dask.array<where, shape=(16,), dtype=float32, chunksize=(4,), chunktype=numpy.ndarray>
axis = None, dtype = None, out = None, min_count = 3

    def nansum(a, axis=None, dtype=None, out=None, min_count=None):
        a, mask = _replace_nan(a, 0)
        result = _dask_or_eager_func("sum")(a, axis=axis, dtype=dtype)
        if min_count is not None:
            if isinstance(axis, (tuple, list)):
                axis = tuple(range(len(a.shape))) if axis is None else axis
                valid_elements = np.take(a.shape, axis).prod()
            else:
>               valid_elements = a.shape[axis]
E               TypeError: tuple indices must be integers or slices, not NoneType

xarray/core/nanops.py:119: TypeError
___________________ test_min_count[None-sum-True-float32-2] ____________________

dim_num = 2, dtype = <class 'numpy.float32'>, dask = True, func = 'sum'
aggdim = None

    @pytest.mark.parametrize("dim_num", [1, 2])
    @pytest.mark.parametrize("dtype", [float, int, np.float32, np.bool_])
    @pytest.mark.parametrize("dask", [False, True])
    @pytest.mark.parametrize("func", ["sum", "prod"])
    @pytest.mark.parametrize("aggdim", [None, "x"])
    def test_min_count(dim_num, dtype, dask, func, aggdim):
        if dask and not has_dask:
            pytest.skip("requires dask")
    
        da = construct_dataarray(dim_num, dtype, contains_nan=True, dask=dask)
        min_count = 3
    
>       actual = getattr(da, func)(dim=aggdim, skipna=True, min_count=min_count)

xarray/tests/test_duck_array_ops.py:592: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/common.py:46: in wrapped_func
    return self.reduce(func, dim, axis, skipna=skipna, **kwargs)
xarray/core/dataarray.py:2347: in reduce
    var = self.variable.reduce(func, dim, axis, keep_attrs, keepdims, **kwargs)
xarray/core/variable.py:1642: in reduce
    data = func(input_data, **kwargs)
xarray/core/duck_array_ops.py:335: in f
    return func(values, axis=axis, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = dask.array<where, shape=(16, 8), dtype=float32, chunksize=(4, 4), chunktype=numpy.ndarray>
axis = None, dtype = None, out = None, min_count = 3

    def nansum(a, axis=None, dtype=None, out=None, min_count=None):
        a, mask = _replace_nan(a, 0)
        result = _dask_or_eager_func("sum")(a, axis=axis, dtype=dtype)
        if min_count is not None:
            if isinstance(axis, (tuple, list)):
                axis = tuple(range(len(a.shape))) if axis is None else axis
                valid_elements = np.take(a.shape, axis).prod()
            else:
>               valid_elements = a.shape[axis]
E               TypeError: tuple indices must be integers or slices, not NoneType

xarray/core/nanops.py:119: TypeError
____________________ test_min_count[None-sum-True-bool_-1] _____________________

dim_num = 1, dtype = <class 'numpy.bool_'>, dask = True, func = 'sum'
aggdim = None

    @pytest.mark.parametrize("dim_num", [1, 2])
    @pytest.mark.parametrize("dtype", [float, int, np.float32, np.bool_])
    @pytest.mark.parametrize("dask", [False, True])
    @pytest.mark.parametrize("func", ["sum", "prod"])
    @pytest.mark.parametrize("aggdim", [None, "x"])
    def test_min_count(dim_num, dtype, dask, func, aggdim):
        if dask and not has_dask:
            pytest.skip("requires dask")
    
        da = construct_dataarray(dim_num, dtype, contains_nan=True, dask=dask)
        min_count = 3
    
>       actual = getattr(da, func)(dim=aggdim, skipna=True, min_count=min_count)

xarray/tests/test_duck_array_ops.py:592: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/common.py:46: in wrapped_func
    return self.reduce(func, dim, axis, skipna=skipna, **kwargs)
xarray/core/dataarray.py:2347: in reduce
    var = self.variable.reduce(func, dim, axis, keep_attrs, keepdims, **kwargs)
xarray/core/variable.py:1642: in reduce
    data = func(input_data, **kwargs)
xarray/core/duck_array_ops.py:335: in f
    return func(values, axis=axis, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = dask.array<where, shape=(16,), dtype=object, chunksize=(4,), chunktype=numpy.ndarray>
axis = None, dtype = None, out = None, min_count = 3

    def nansum(a, axis=None, dtype=None, out=None, min_count=None):
        a, mask = _replace_nan(a, 0)
        result = _dask_or_eager_func("sum")(a, axis=axis, dtype=dtype)
        if min_count is not None:
            if isinstance(axis, (tuple, list)):
                axis = tuple(range(len(a.shape))) if axis is None else axis
                valid_elements = np.take(a.shape, axis).prod()
            else:
>               valid_elements = a.shape[axis]
E               TypeError: tuple indices must be integers or slices, not NoneType

xarray/core/nanops.py:119: TypeError
____________________ test_min_count[None-sum-True-bool_-2] _____________________

dim_num = 2, dtype = <class 'numpy.bool_'>, dask = True, func = 'sum'
aggdim = None

    @pytest.mark.parametrize("dim_num", [1, 2])
    @pytest.mark.parametrize("dtype", [float, int, np.float32, np.bool_])
    @pytest.mark.parametrize("dask", [False, True])
    @pytest.mark.parametrize("func", ["sum", "prod"])
    @pytest.mark.parametrize("aggdim", [None, "x"])
    def test_min_count(dim_num, dtype, dask, func, aggdim):
        if dask and not has_dask:
            pytest.skip("requires dask")
    
        da = construct_dataarray(dim_num, dtype, contains_nan=True, dask=dask)
        min_count = 3
    
>       actual = getattr(da, func)(dim=aggdim, skipna=True, min_count=min_count)

xarray/tests/test_duck_array_ops.py:592: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/common.py:46: in wrapped_func
    return self.reduce(func, dim, axis, skipna=skipna, **kwargs)
xarray/core/dataarray.py:2347: in reduce
    var = self.variable.reduce(func, dim, axis, keep_attrs, keepdims, **kwargs)
xarray/core/variable.py:1642: in reduce
    data = func(input_data, **kwargs)
xarray/core/duck_array_ops.py:335: in f
    return func(values, axis=axis, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = dask.array<where, shape=(16, 8), dtype=object, chunksize=(4, 4), chunktype=numpy.ndarray>
axis = None, dtype = None, out = None, min_count = 3

    def nansum(a, axis=None, dtype=None, out=None, min_count=None):
        a, mask = _replace_nan(a, 0)
        result = _dask_or_eager_func("sum")(a, axis=axis, dtype=dtype)
        if min_count is not None:
            if isinstance(axis, (tuple, list)):
                axis = tuple(range(len(a.shape))) if axis is None else axis
                valid_elements = np.take(a.shape, axis).prod()
            else:
>               valid_elements = a.shape[axis]
E               TypeError: tuple indices must be integers or slices, not NoneType

xarray/core/nanops.py:119: TypeError
_____________________ test_min_count[x-sum-False-float-1] ______________________

dim_num = 1, dtype = <class 'float'>, dask = False, func = 'sum', aggdim = 'x'

    @pytest.mark.parametrize("dim_num", [1, 2])
    @pytest.mark.parametrize("dtype", [float, int, np.float32, np.bool_])
    @pytest.mark.parametrize("dask", [False, True])
    @pytest.mark.parametrize("func", ["sum", "prod"])
    @pytest.mark.parametrize("aggdim", [None, "x"])
    def test_min_count(dim_num, dtype, dask, func, aggdim):
        if dask and not has_dask:
            pytest.skip("requires dask")
    
        da = construct_dataarray(dim_num, dtype, contains_nan=True, dask=dask)
        min_count = 3
    
>       actual = getattr(da, func)(dim=aggdim, skipna=True, min_count=min_count)

xarray/tests/test_duck_array_ops.py:592: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/common.py:46: in wrapped_func
    return self.reduce(func, dim, axis, skipna=skipna, **kwargs)
xarray/core/dataarray.py:2347: in reduce
    var = self.variable.reduce(func, dim, axis, keep_attrs, keepdims, **kwargs)
xarray/core/variable.py:1640: in reduce
    data = func(input_data, axis=axis, **kwargs)
xarray/core/duck_array_ops.py:335: in f
    return func(values, axis=axis, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = array([ 1.76405235,  0.40015721,  0.        ,  0.        ,  1.86755799,
       -0.97727788,  0.95008842, -0.15135721,  0.        ,  0.4105985 ,
        0.14404357,  1.45427351,  0.76103773,  0.12167502,  0.44386323,
        0.33367433])
axis = 0, dtype = None, out = None, min_count = 3

    def nansum(a, axis=None, dtype=None, out=None, min_count=None):
        a, mask = _replace_nan(a, 0)
        result = _dask_or_eager_func("sum")(a, axis=axis, dtype=dtype)
        if min_count is not None:
            if isinstance(axis, (tuple, list)):
                axis = tuple(range(len(a.shape))) if axis is None else axis
                valid_elements = np.take(a.shape, axis).prod()
            else:
                valid_elements = a.shape[axis]
>           return _maybe_null_out(result, axis, mask, min_count, valid_elements)
E           TypeError: _maybe_null_out() takes from 3 to 4 positional arguments but 5 were given

xarray/core/nanops.py:120: TypeError
_____________________ test_min_count[x-sum-False-float-2] ______________________

dim_num = 2, dtype = <class 'float'>, dask = False, func = 'sum', aggdim = 'x'

    @pytest.mark.parametrize("dim_num", [1, 2])
    @pytest.mark.parametrize("dtype", [float, int, np.float32, np.bool_])
    @pytest.mark.parametrize("dask", [False, True])
    @pytest.mark.parametrize("func", ["sum", "prod"])
    @pytest.mark.parametrize("aggdim", [None, "x"])
    def test_min_count(dim_num, dtype, dask, func, aggdim):
        if dask and not has_dask:
            pytest.skip("requires dask")
    
        da = construct_dataarray(dim_num, dtype, contains_nan=True, dask=dask)
        min_count = 3
    
>       actual = getattr(da, func)(dim=aggdim, skipna=True, min_count=min_count)

xarray/tests/test_duck_array_ops.py:592: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/common.py:46: in wrapped_func
    return self.reduce(func, dim, axis, skipna=skipna, **kwargs)
xarray/core/dataarray.py:2347: in reduce
    var = self.variable.reduce(func, dim, axis, keep_attrs, keepdims, **kwargs)
xarray/core/variable.py:1640: in reduce
    data = func(input_data, axis=axis, **kwargs)
xarray/core/duck_array_ops.py:335: in f
    return func(values, axis=axis, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = array([[ 0.        ,  0.40015721,  0.97873798,  0.        ,  1.86755799,
         0.        ,  0.95008842, -0.15135721...     [ 0.37642553, -1.09940079,  0.29823817,  1.3263859 , -0.69456786,
        -0.14963454, -0.43515355,  0.        ]])
axis = 0, dtype = None, out = None, min_count = 3

    def nansum(a, axis=None, dtype=None, out=None, min_count=None):
        a, mask = _replace_nan(a, 0)
        result = _dask_or_eager_func("sum")(a, axis=axis, dtype=dtype)
        if min_count is not None:
            if isinstance(axis, (tuple, list)):
                axis = tuple(range(len(a.shape))) if axis is None else axis
                valid_elements = np.take(a.shape, axis).prod()
            else:
                valid_elements = a.shape[axis]
>           return _maybe_null_out(result, axis, mask, min_count, valid_elements)
E           TypeError: _maybe_null_out() takes from 3 to 4 positional arguments but 5 were given

xarray/core/nanops.py:120: TypeError
______________________ test_min_count[x-sum-False-int-1] _______________________

dim_num = 1, dtype = <class 'int'>, dask = False, func = 'sum', aggdim = 'x'

    @pytest.mark.parametrize("dim_num", [1, 2])
    @pytest.mark.parametrize("dtype", [float, int, np.float32, np.bool_])
    @pytest.mark.parametrize("dask", [False, True])
    @pytest.mark.parametrize("func", ["sum", "prod"])
    @pytest.mark.parametrize("aggdim", [None, "x"])
    def test_min_count(dim_num, dtype, dask, func, aggdim):
        if dask and not has_dask:
            pytest.skip("requires dask")
    
        da = construct_dataarray(dim_num, dtype, contains_nan=True, dask=dask)
        min_count = 3
    
>       actual = getattr(da, func)(dim=aggdim, skipna=True, min_count=min_count)

xarray/tests/test_duck_array_ops.py:592: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/common.py:46: in wrapped_func
    return self.reduce(func, dim, axis, skipna=skipna, **kwargs)
xarray/core/dataarray.py:2347: in reduce
    var = self.variable.reduce(func, dim, axis, keep_attrs, keepdims, **kwargs)
xarray/core/variable.py:1640: in reduce
    data = func(input_data, axis=axis, **kwargs)
xarray/core/duck_array_ops.py:335: in f
    return func(values, axis=axis, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = array([5., 0., 3., 3., 7., 9., 3., 0., 2., 4., 7., 6., 8., 8., 0., 6.])
axis = 0, dtype = None, out = None, min_count = 3

    def nansum(a, axis=None, dtype=None, out=None, min_count=None):
        a, mask = _replace_nan(a, 0)
        result = _dask_or_eager_func("sum")(a, axis=axis, dtype=dtype)
        if min_count is not None:
            if isinstance(axis, (tuple, list)):
                axis = tuple(range(len(a.shape))) if axis is None else axis
                valid_elements = np.take(a.shape, axis).prod()
            else:
                valid_elements = a.shape[axis]
>           return _maybe_null_out(result, axis, mask, min_count, valid_elements)
E           TypeError: _maybe_null_out() takes from 3 to 4 positional arguments but 5 were given

xarray/core/nanops.py:120: TypeError
______________________ test_min_count[x-sum-False-int-2] _______________________

dim_num = 2, dtype = <class 'int'>, dask = False, func = 'sum', aggdim = 'x'

    @pytest.mark.parametrize("dim_num", [1, 2])
    @pytest.mark.parametrize("dtype", [float, int, np.float32, np.bool_])
    @pytest.mark.parametrize("dask", [False, True])
    @pytest.mark.parametrize("func", ["sum", "prod"])
    @pytest.mark.parametrize("aggdim", [None, "x"])
    def test_min_count(dim_num, dtype, dask, func, aggdim):
        if dask and not has_dask:
            pytest.skip("requires dask")
    
        da = construct_dataarray(dim_num, dtype, contains_nan=True, dask=dask)
        min_count = 3
    
>       actual = getattr(da, func)(dim=aggdim, skipna=True, min_count=min_count)

xarray/tests/test_duck_array_ops.py:592: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/common.py:46: in wrapped_func
    return self.reduce(func, dim, axis, skipna=skipna, **kwargs)
xarray/core/dataarray.py:2347: in reduce
    var = self.variable.reduce(func, dim, axis, keep_attrs, keepdims, **kwargs)
xarray/core/variable.py:1640: in reduce
    data = func(input_data, axis=axis, **kwargs)
xarray/core/duck_array_ops.py:335: in f
    return func(values, axis=axis, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = array([[0., 0., 0., 0., 7., 9., 3., 5.],
       [2., 4., 7., 6., 8., 0., 1., 6.],
       [7., 7., 8., 0., 5., 9., 8., ...   [0., 5., 9., 0., 2., 7., 2., 9.],
       [0., 3., 3., 0., 3., 4., 1., 2.],
       [9., 1., 4., 6., 8., 0., 3., 0.]])
axis = 0, dtype = None, out = None, min_count = 3

    def nansum(a, axis=None, dtype=None, out=None, min_count=None):
        a, mask = _replace_nan(a, 0)
        result = _dask_or_eager_func("sum")(a, axis=axis, dtype=dtype)
        if min_count is not None:
            if isinstance(axis, (tuple, list)):
                axis = tuple(range(len(a.shape))) if axis is None else axis
                valid_elements = np.take(a.shape, axis).prod()
            else:
                valid_elements = a.shape[axis]
>           return _maybe_null_out(result, axis, mask, min_count, valid_elements)
E           TypeError: _maybe_null_out() takes from 3 to 4 positional arguments but 5 were given

xarray/core/nanops.py:120: TypeError
____________________ test_min_count[x-sum-False-float32-1] _____________________

dim_num = 1, dtype = <class 'numpy.float32'>, dask = False, func = 'sum'
aggdim = 'x'

    @pytest.mark.parametrize("dim_num", [1, 2])
    @pytest.mark.parametrize("dtype", [float, int, np.float32, np.bool_])
    @pytest.mark.parametrize("dask", [False, True])
    @pytest.mark.parametrize("func", ["sum", "prod"])
    @pytest.mark.parametrize("aggdim", [None, "x"])
    def test_min_count(dim_num, dtype, dask, func, aggdim):
        if dask and not has_dask:
            pytest.skip("requires dask")
    
        da = construct_dataarray(dim_num, dtype, contains_nan=True, dask=dask)
        min_count = 3
    
>       actual = getattr(da, func)(dim=aggdim, skipna=True, min_count=min_count)

xarray/tests/test_duck_array_ops.py:592: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/common.py:46: in wrapped_func
    return self.reduce(func, dim, axis, skipna=skipna, **kwargs)
xarray/core/dataarray.py:2347: in reduce
    var = self.variable.reduce(func, dim, axis, keep_attrs, keepdims, **kwargs)
xarray/core/variable.py:1640: in reduce
    data = func(input_data, axis=axis, **kwargs)
xarray/core/duck_array_ops.py:335: in f
    return func(values, axis=axis, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = array([ 1.7640524 ,  0.4001572 ,  0.        ,  0.        ,  1.867558  ,
       -0.9772779 ,  0.95008844, -0.1513572 , ...0.41059852,
        0.14404356,  1.4542735 ,  0.7610377 ,  0.12167501,  0.44386324,
        0.33367434], dtype=float32)
axis = 0, dtype = None, out = None, min_count = 3

    def nansum(a, axis=None, dtype=None, out=None, min_count=None):
        a, mask = _replace_nan(a, 0)
        result = _dask_or_eager_func("sum")(a, axis=axis, dtype=dtype)
        if min_count is not None:
            if isinstance(axis, (tuple, list)):
                axis = tuple(range(len(a.shape))) if axis is None else axis
                valid_elements = np.take(a.shape, axis).prod()
            else:
                valid_elements = a.shape[axis]
>           return _maybe_null_out(result, axis, mask, min_count, valid_elements)
E           TypeError: _maybe_null_out() takes from 3 to 4 positional arguments but 5 were given

xarray/core/nanops.py:120: TypeError
____________________ test_min_count[x-sum-False-float32-2] _____________________

dim_num = 2, dtype = <class 'numpy.float32'>, dask = False, func = 'sum'
aggdim = 'x'

    @pytest.mark.parametrize("dim_num", [1, 2])
    @pytest.mark.parametrize("dtype", [float, int, np.float32, np.bool_])
    @pytest.mark.parametrize("dask", [False, True])
    @pytest.mark.parametrize("func", ["sum", "prod"])
    @pytest.mark.parametrize("aggdim", [None, "x"])
    def test_min_count(dim_num, dtype, dask, func, aggdim):
        if dask and not has_dask:
            pytest.skip("requires dask")
    
        da = construct_dataarray(dim_num, dtype, contains_nan=True, dask=dask)
        min_count = 3
    
>       actual = getattr(da, func)(dim=aggdim, skipna=True, min_count=min_count)

xarray/tests/test_duck_array_ops.py:592: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/common.py:46: in wrapped_func
    return self.reduce(func, dim, axis, skipna=skipna, **kwargs)
xarray/core/dataarray.py:2347: in reduce
    var = self.variable.reduce(func, dim, axis, keep_attrs, keepdims, **kwargs)
xarray/core/variable.py:1640: in reduce
    data = func(input_data, axis=axis, **kwargs)
xarray/core/duck_array_ops.py:335: in f
    return func(values, axis=axis, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = array([[ 0.        ,  0.4001572 ,  0.978738  ,  0.        ,  1.867558  ,
         0.        ,  0.95008844, -0.1513572 ...53, -1.0994008 ,  0.2982382 ,  1.3263859 , -0.69456786,
        -0.14963454, -0.43515354,  0.        ]], dtype=float32)
axis = 0, dtype = None, out = None, min_count = 3

    def nansum(a, axis=None, dtype=None, out=None, min_count=None):
        a, mask = _replace_nan(a, 0)
        result = _dask_or_eager_func("sum")(a, axis=axis, dtype=dtype)
        if min_count is not None:
            if isinstance(axis, (tuple, list)):
                axis = tuple(range(len(a.shape))) if axis is None else axis
                valid_elements = np.take(a.shape, axis).prod()
            else:
                valid_elements = a.shape[axis]
>           return _maybe_null_out(result, axis, mask, min_count, valid_elements)
E           TypeError: _maybe_null_out() takes from 3 to 4 positional arguments but 5 were given

xarray/core/nanops.py:120: TypeError
_____________________ test_min_count[x-sum-False-bool_-1] ______________________

dim_num = 1, dtype = <class 'numpy.bool_'>, dask = False, func = 'sum'
aggdim = 'x'

    @pytest.mark.parametrize("dim_num", [1, 2])
    @pytest.mark.parametrize("dtype", [float, int, np.float32, np.bool_])
    @pytest.mark.parametrize("dask", [False, True])
    @pytest.mark.parametrize("func", ["sum", "prod"])
    @pytest.mark.parametrize("aggdim", [None, "x"])
    def test_min_count(dim_num, dtype, dask, func, aggdim):
        if dask and not has_dask:
            pytest.skip("requires dask")
    
        da = construct_dataarray(dim_num, dtype, contains_nan=True, dask=dask)
        min_count = 3
    
>       actual = getattr(da, func)(dim=aggdim, skipna=True, min_count=min_count)

xarray/tests/test_duck_array_ops.py:592: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/common.py:46: in wrapped_func
    return self.reduce(func, dim, axis, skipna=skipna, **kwargs)
xarray/core/dataarray.py:2347: in reduce
    var = self.variable.reduce(func, dim, axis, keep_attrs, keepdims, **kwargs)
xarray/core/variable.py:1640: in reduce
    data = func(input_data, axis=axis, **kwargs)
xarray/core/duck_array_ops.py:335: in f
    return func(values, axis=axis, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = array([False, False, False, False, False, 0, False, False, False, False,
       False, False, 0, False, False, 0], dtype=object)
axis = 0, dtype = None, out = None, min_count = 3

    def nansum(a, axis=None, dtype=None, out=None, min_count=None):
        a, mask = _replace_nan(a, 0)
        result = _dask_or_eager_func("sum")(a, axis=axis, dtype=dtype)
        if min_count is not None:
            if isinstance(axis, (tuple, list)):
                axis = tuple(range(len(a.shape))) if axis is None else axis
                valid_elements = np.take(a.shape, axis).prod()
            else:
                valid_elements = a.shape[axis]
>           return _maybe_null_out(result, axis, mask, min_count, valid_elements)
E           TypeError: _maybe_null_out() takes from 3 to 4 positional arguments but 5 were given

xarray/core/nanops.py:120: TypeError
_____________________ test_min_count[x-sum-False-bool_-2] ______________________

dim_num = 2, dtype = <class 'numpy.bool_'>, dask = False, func = 'sum'
aggdim = 'x'

    @pytest.mark.parametrize("dim_num", [1, 2])
    @pytest.mark.parametrize("dtype", [float, int, np.float32, np.bool_])
    @pytest.mark.parametrize("dask", [False, True])
    @pytest.mark.parametrize("func", ["sum", "prod"])
    @pytest.mark.parametrize("aggdim", [None, "x"])
    def test_min_count(dim_num, dtype, dask, func, aggdim):
        if dask and not has_dask:
            pytest.skip("requires dask")
    
        da = construct_dataarray(dim_num, dtype, contains_nan=True, dask=dask)
        min_count = 3
    
>       actual = getattr(da, func)(dim=aggdim, skipna=True, min_count=min_count)

xarray/tests/test_duck_array_ops.py:592: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/common.py:46: in wrapped_func
    return self.reduce(func, dim, axis, skipna=skipna, **kwargs)
xarray/core/dataarray.py:2347: in reduce
    var = self.variable.reduce(func, dim, axis, keep_attrs, keepdims, **kwargs)
xarray/core/variable.py:1640: in reduce
    data = func(input_data, axis=axis, **kwargs)
xarray/core/duck_array_ops.py:335: in f
    return func(values, axis=axis, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = array([[False, False, False, False, False, False, False, False],
       [False, 0, False, False, 0, False, False, Fals..., False, 0, False, False, 0, False, False],
       [False, False, False, 0, False, False, False, False]], dtype=object)
axis = 0, dtype = None, out = None, min_count = 3

    def nansum(a, axis=None, dtype=None, out=None, min_count=None):
        a, mask = _replace_nan(a, 0)
        result = _dask_or_eager_func("sum")(a, axis=axis, dtype=dtype)
        if min_count is not None:
            if isinstance(axis, (tuple, list)):
                axis = tuple(range(len(a.shape))) if axis is None else axis
                valid_elements = np.take(a.shape, axis).prod()
            else:
                valid_elements = a.shape[axis]
>           return _maybe_null_out(result, axis, mask, min_count, valid_elements)
E           TypeError: _maybe_null_out() takes from 3 to 4 positional arguments but 5 were given

xarray/core/nanops.py:120: TypeError
______________________ test_min_count[x-sum-True-float-1] ______________________

dim_num = 1, dtype = <class 'float'>, dask = True, func = 'sum', aggdim = 'x'

    @pytest.mark.parametrize("dim_num", [1, 2])
    @pytest.mark.parametrize("dtype", [float, int, np.float32, np.bool_])
    @pytest.mark.parametrize("dask", [False, True])
    @pytest.mark.parametrize("func", ["sum", "prod"])
    @pytest.mark.parametrize("aggdim", [None, "x"])
    def test_min_count(dim_num, dtype, dask, func, aggdim):
        if dask and not has_dask:
            pytest.skip("requires dask")
    
        da = construct_dataarray(dim_num, dtype, contains_nan=True, dask=dask)
        min_count = 3
    
>       actual = getattr(da, func)(dim=aggdim, skipna=True, min_count=min_count)

xarray/tests/test_duck_array_ops.py:592: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/common.py:46: in wrapped_func
    return self.reduce(func, dim, axis, skipna=skipna, **kwargs)
xarray/core/dataarray.py:2347: in reduce
    var = self.variable.reduce(func, dim, axis, keep_attrs, keepdims, **kwargs)
xarray/core/variable.py:1640: in reduce
    data = func(input_data, axis=axis, **kwargs)
xarray/core/duck_array_ops.py:335: in f
    return func(values, axis=axis, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = dask.array<where, shape=(16,), dtype=float64, chunksize=(4,), chunktype=numpy.ndarray>
axis = 0, dtype = None, out = None, min_count = 3

    def nansum(a, axis=None, dtype=None, out=None, min_count=None):
        a, mask = _replace_nan(a, 0)
        result = _dask_or_eager_func("sum")(a, axis=axis, dtype=dtype)
        if min_count is not None:
            if isinstance(axis, (tuple, list)):
                axis = tuple(range(len(a.shape))) if axis is None else axis
                valid_elements = np.take(a.shape, axis).prod()
            else:
                valid_elements = a.shape[axis]
>           return _maybe_null_out(result, axis, mask, min_count, valid_elements)
E           TypeError: _maybe_null_out() takes from 3 to 4 positional arguments but 5 were given

xarray/core/nanops.py:120: TypeError
______________________ test_min_count[x-sum-True-float-2] ______________________

dim_num = 2, dtype = <class 'float'>, dask = True, func = 'sum', aggdim = 'x'

    @pytest.mark.parametrize("dim_num", [1, 2])
    @pytest.mark.parametrize("dtype", [float, int, np.float32, np.bool_])
    @pytest.mark.parametrize("dask", [False, True])
    @pytest.mark.parametrize("func", ["sum", "prod"])
    @pytest.mark.parametrize("aggdim", [None, "x"])
    def test_min_count(dim_num, dtype, dask, func, aggdim):
        if dask and not has_dask:
            pytest.skip("requires dask")
    
        da = construct_dataarray(dim_num, dtype, contains_nan=True, dask=dask)
        min_count = 3
    
>       actual = getattr(da, func)(dim=aggdim, skipna=True, min_count=min_count)

xarray/tests/test_duck_array_ops.py:592: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/common.py:46: in wrapped_func
    return self.reduce(func, dim, axis, skipna=skipna, **kwargs)
xarray/core/dataarray.py:2347: in reduce
    var = self.variable.reduce(func, dim, axis, keep_attrs, keepdims, **kwargs)
xarray/core/variable.py:1640: in reduce
    data = func(input_data, axis=axis, **kwargs)
xarray/core/duck_array_ops.py:335: in f
    return func(values, axis=axis, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = dask.array<where, shape=(16, 8), dtype=float64, chunksize=(4, 4), chunktype=numpy.ndarray>
axis = 0, dtype = None, out = None, min_count = 3

    def nansum(a, axis=None, dtype=None, out=None, min_count=None):
        a, mask = _replace_nan(a, 0)
        result = _dask_or_eager_func("sum")(a, axis=axis, dtype=dtype)
        if min_count is not None:
            if isinstance(axis, (tuple, list)):
                axis = tuple(range(len(a.shape))) if axis is None else axis
                valid_elements = np.take(a.shape, axis).prod()
            else:
                valid_elements = a.shape[axis]
>           return _maybe_null_out(result, axis, mask, min_count, valid_elements)
E           TypeError: _maybe_null_out() takes from 3 to 4 positional arguments but 5 were given

xarray/core/nanops.py:120: TypeError
_______________________ test_min_count[x-sum-True-int-1] _______________________

dim_num = 1, dtype = <class 'int'>, dask = True, func = 'sum', aggdim = 'x'

    @pytest.mark.parametrize("dim_num", [1, 2])
    @pytest.mark.parametrize("dtype", [float, int, np.float32, np.bool_])
    @pytest.mark.parametrize("dask", [False, True])
    @pytest.mark.parametrize("func", ["sum", "prod"])
    @pytest.mark.parametrize("aggdim", [None, "x"])
    def test_min_count(dim_num, dtype, dask, func, aggdim):
        if dask and not has_dask:
            pytest.skip("requires dask")
    
        da = construct_dataarray(dim_num, dtype, contains_nan=True, dask=dask)
        min_count = 3
    
>       actual = getattr(da, func)(dim=aggdim, skipna=True, min_count=min_count)

xarray/tests/test_duck_array_ops.py:592: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/common.py:46: in wrapped_func
    return self.reduce(func, dim, axis, skipna=skipna, **kwargs)
xarray/core/dataarray.py:2347: in reduce
    var = self.variable.reduce(func, dim, axis, keep_attrs, keepdims, **kwargs)
xarray/core/variable.py:1640: in reduce
    data = func(input_data, axis=axis, **kwargs)
xarray/core/duck_array_ops.py:335: in f
    return func(values, axis=axis, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = dask.array<where, shape=(16,), dtype=float64, chunksize=(4,), chunktype=numpy.ndarray>
axis = 0, dtype = None, out = None, min_count = 3

    def nansum(a, axis=None, dtype=None, out=None, min_count=None):
        a, mask = _replace_nan(a, 0)
        result = _dask_or_eager_func("sum")(a, axis=axis, dtype=dtype)
        if min_count is not None:
            if isinstance(axis, (tuple, list)):
                axis = tuple(range(len(a.shape))) if axis is None else axis
                valid_elements = np.take(a.shape, axis).prod()
            else:
                valid_elements = a.shape[axis]
>           return _maybe_null_out(result, axis, mask, min_count, valid_elements)
E           TypeError: _maybe_null_out() takes from 3 to 4 positional arguments but 5 were given

xarray/core/nanops.py:120: TypeError
_______________________ test_min_count[x-sum-True-int-2] _______________________

dim_num = 2, dtype = <class 'int'>, dask = True, func = 'sum', aggdim = 'x'

    @pytest.mark.parametrize("dim_num", [1, 2])
    @pytest.mark.parametrize("dtype", [float, int, np.float32, np.bool_])
    @pytest.mark.parametrize("dask", [False, True])
    @pytest.mark.parametrize("func", ["sum", "prod"])
    @pytest.mark.parametrize("aggdim", [None, "x"])
    def test_min_count(dim_num, dtype, dask, func, aggdim):
        if dask and not has_dask:
            pytest.skip("requires dask")
    
        da = construct_dataarray(dim_num, dtype, contains_nan=True, dask=dask)
        min_count = 3
    
>       actual = getattr(da, func)(dim=aggdim, skipna=True, min_count=min_count)

xarray/tests/test_duck_array_ops.py:592: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/common.py:46: in wrapped_func
    return self.reduce(func, dim, axis, skipna=skipna, **kwargs)
xarray/core/dataarray.py:2347: in reduce
    var = self.variable.reduce(func, dim, axis, keep_attrs, keepdims, **kwargs)
xarray/core/variable.py:1640: in reduce
    data = func(input_data, axis=axis, **kwargs)
xarray/core/duck_array_ops.py:335: in f
    return func(values, axis=axis, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = dask.array<where, shape=(16, 8), dtype=float64, chunksize=(4, 4), chunktype=numpy.ndarray>
axis = 0, dtype = None, out = None, min_count = 3

    def nansum(a, axis=None, dtype=None, out=None, min_count=None):
        a, mask = _replace_nan(a, 0)
        result = _dask_or_eager_func("sum")(a, axis=axis, dtype=dtype)
        if min_count is not None:
            if isinstance(axis, (tuple, list)):
                axis = tuple(range(len(a.shape))) if axis is None else axis
                valid_elements = np.take(a.shape, axis).prod()
            else:
                valid_elements = a.shape[axis]
>           return _maybe_null_out(result, axis, mask, min_count, valid_elements)
E           TypeError: _maybe_null_out() takes from 3 to 4 positional arguments but 5 were given

xarray/core/nanops.py:120: TypeError
_____________________ test_min_count[x-sum-True-float32-1] _____________________

dim_num = 1, dtype = <class 'numpy.float32'>, dask = True, func = 'sum'
aggdim = 'x'

    @pytest.mark.parametrize("dim_num", [1, 2])
    @pytest.mark.parametrize("dtype", [float, int, np.float32, np.bool_])
    @pytest.mark.parametrize("dask", [False, True])
    @pytest.mark.parametrize("func", ["sum", "prod"])
    @pytest.mark.parametrize("aggdim", [None, "x"])
    def test_min_count(dim_num, dtype, dask, func, aggdim):
        if dask and not has_dask:
            pytest.skip("requires dask")
    
        da = construct_dataarray(dim_num, dtype, contains_nan=True, dask=dask)
        min_count = 3
    
>       actual = getattr(da, func)(dim=aggdim, skipna=True, min_count=min_count)

xarray/tests/test_duck_array_ops.py:592: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/common.py:46: in wrapped_func
    return self.reduce(func, dim, axis, skipna=skipna, **kwargs)
xarray/core/dataarray.py:2347: in reduce
    var = self.variable.reduce(func, dim, axis, keep_attrs, keepdims, **kwargs)
xarray/core/variable.py:1640: in reduce
    data = func(input_data, axis=axis, **kwargs)
xarray/core/duck_array_ops.py:335: in f
    return func(values, axis=axis, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = dask.array<where, shape=(16,), dtype=float32, chunksize=(4,), chunktype=numpy.ndarray>
axis = 0, dtype = None, out = None, min_count = 3

    def nansum(a, axis=None, dtype=None, out=None, min_count=None):
        a, mask = _replace_nan(a, 0)
        result = _dask_or_eager_func("sum")(a, axis=axis, dtype=dtype)
        if min_count is not None:
            if isinstance(axis, (tuple, list)):
                axis = tuple(range(len(a.shape))) if axis is None else axis
                valid_elements = np.take(a.shape, axis).prod()
            else:
                valid_elements = a.shape[axis]
>           return _maybe_null_out(result, axis, mask, min_count, valid_elements)
E           TypeError: _maybe_null_out() takes from 3 to 4 positional arguments but 5 were given

xarray/core/nanops.py:120: TypeError
_____________________ test_min_count[x-sum-True-float32-2] _____________________

dim_num = 2, dtype = <class 'numpy.float32'>, dask = True, func = 'sum'
aggdim = 'x'

    @pytest.mark.parametrize("dim_num", [1, 2])
    @pytest.mark.parametrize("dtype", [float, int, np.float32, np.bool_])
    @pytest.mark.parametrize("dask", [False, True])
    @pytest.mark.parametrize("func", ["sum", "prod"])
    @pytest.mark.parametrize("aggdim", [None, "x"])
    def test_min_count(dim_num, dtype, dask, func, aggdim):
        if dask and not has_dask:
            pytest.skip("requires dask")
    
        da = construct_dataarray(dim_num, dtype, contains_nan=True, dask=dask)
        min_count = 3
    
>       actual = getattr(da, func)(dim=aggdim, skipna=True, min_count=min_count)

xarray/tests/test_duck_array_ops.py:592: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/common.py:46: in wrapped_func
    return self.reduce(func, dim, axis, skipna=skipna, **kwargs)
xarray/core/dataarray.py:2347: in reduce
    var = self.variable.reduce(func, dim, axis, keep_attrs, keepdims, **kwargs)
xarray/core/variable.py:1640: in reduce
    data = func(input_data, axis=axis, **kwargs)
xarray/core/duck_array_ops.py:335: in f
    return func(values, axis=axis, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = dask.array<where, shape=(16, 8), dtype=float32, chunksize=(4, 4), chunktype=numpy.ndarray>
axis = 0, dtype = None, out = None, min_count = 3

    def nansum(a, axis=None, dtype=None, out=None, min_count=None):
        a, mask = _replace_nan(a, 0)
        result = _dask_or_eager_func("sum")(a, axis=axis, dtype=dtype)
        if min_count is not None:
            if isinstance(axis, (tuple, list)):
                axis = tuple(range(len(a.shape))) if axis is None else axis
                valid_elements = np.take(a.shape, axis).prod()
            else:
                valid_elements = a.shape[axis]
>           return _maybe_null_out(result, axis, mask, min_count, valid_elements)
E           TypeError: _maybe_null_out() takes from 3 to 4 positional arguments but 5 were given

xarray/core/nanops.py:120: TypeError
______________________ test_min_count[x-sum-True-bool_-1] ______________________

dim_num = 1, dtype = <class 'numpy.bool_'>, dask = True, func = 'sum'
aggdim = 'x'

    @pytest.mark.parametrize("dim_num", [1, 2])
    @pytest.mark.parametrize("dtype", [float, int, np.float32, np.bool_])
    @pytest.mark.parametrize("dask", [False, True])
    @pytest.mark.parametrize("func", ["sum", "prod"])
    @pytest.mark.parametrize("aggdim", [None, "x"])
    def test_min_count(dim_num, dtype, dask, func, aggdim):
        if dask and not has_dask:
            pytest.skip("requires dask")
    
        da = construct_dataarray(dim_num, dtype, contains_nan=True, dask=dask)
        min_count = 3
    
>       actual = getattr(da, func)(dim=aggdim, skipna=True, min_count=min_count)

xarray/tests/test_duck_array_ops.py:592: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/common.py:46: in wrapped_func
    return self.reduce(func, dim, axis, skipna=skipna, **kwargs)
xarray/core/dataarray.py:2347: in reduce
    var = self.variable.reduce(func, dim, axis, keep_attrs, keepdims, **kwargs)
xarray/core/variable.py:1640: in reduce
    data = func(input_data, axis=axis, **kwargs)
xarray/core/duck_array_ops.py:335: in f
    return func(values, axis=axis, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = dask.array<where, shape=(16,), dtype=object, chunksize=(4,), chunktype=numpy.ndarray>
axis = 0, dtype = None, out = None, min_count = 3

    def nansum(a, axis=None, dtype=None, out=None, min_count=None):
        a, mask = _replace_nan(a, 0)
        result = _dask_or_eager_func("sum")(a, axis=axis, dtype=dtype)
        if min_count is not None:
            if isinstance(axis, (tuple, list)):
                axis = tuple(range(len(a.shape))) if axis is None else axis
                valid_elements = np.take(a.shape, axis).prod()
            else:
                valid_elements = a.shape[axis]
>           return _maybe_null_out(result, axis, mask, min_count, valid_elements)
E           TypeError: _maybe_null_out() takes from 3 to 4 positional arguments but 5 were given

xarray/core/nanops.py:120: TypeError
______________________ test_min_count[x-sum-True-bool_-2] ______________________

dim_num = 2, dtype = <class 'numpy.bool_'>, dask = True, func = 'sum'
aggdim = 'x'

    @pytest.mark.parametrize("dim_num", [1, 2])
    @pytest.mark.parametrize("dtype", [float, int, np.float32, np.bool_])
    @pytest.mark.parametrize("dask", [False, True])
    @pytest.mark.parametrize("func", ["sum", "prod"])
    @pytest.mark.parametrize("aggdim", [None, "x"])
    def test_min_count(dim_num, dtype, dask, func, aggdim):
        if dask and not has_dask:
            pytest.skip("requires dask")
    
        da = construct_dataarray(dim_num, dtype, contains_nan=True, dask=dask)
        min_count = 3
    
>       actual = getattr(da, func)(dim=aggdim, skipna=True, min_count=min_count)

xarray/tests/test_duck_array_ops.py:592: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/common.py:46: in wrapped_func
    return self.reduce(func, dim, axis, skipna=skipna, **kwargs)
xarray/core/dataarray.py:2347: in reduce
    var = self.variable.reduce(func, dim, axis, keep_attrs, keepdims, **kwargs)
xarray/core/variable.py:1640: in reduce
    data = func(input_data, axis=axis, **kwargs)
xarray/core/duck_array_ops.py:335: in f
    return func(values, axis=axis, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = dask.array<where, shape=(16, 8), dtype=object, chunksize=(4, 4), chunktype=numpy.ndarray>
axis = 0, dtype = None, out = None, min_count = 3

    def nansum(a, axis=None, dtype=None, out=None, min_count=None):
        a, mask = _replace_nan(a, 0)
        result = _dask_or_eager_func("sum")(a, axis=axis, dtype=dtype)
        if min_count is not None:
            if isinstance(axis, (tuple, list)):
                axis = tuple(range(len(a.shape))) if axis is None else axis
                valid_elements = np.take(a.shape, axis).prod()
            else:
                valid_elements = a.shape[axis]
>           return _maybe_null_out(result, axis, mask, min_count, valid_elements)
E           TypeError: _maybe_null_out() takes from 3 to 4 positional arguments but 5 were given

xarray/core/nanops.py:120: TypeError
______________________ test_min_count_nd[sum-False-float] ______________________

dtype = <class 'float'>, dask = False, func = 'sum'

    @pytest.mark.parametrize("dtype", [float, int, np.float32, np.bool_])
    @pytest.mark.parametrize("dask", [False, True])
    @pytest.mark.parametrize("func", ["sum", "prod"])
    def test_min_count_nd(dtype, dask, func):
        if dask and not has_dask:
            pytest.skip("requires dask")
    
        min_count = 3
        dim_num = 3
        da = construct_dataarray(dim_num, dtype, contains_nan=True, dask=dask)
>       actual = getattr(da, func)(dim=["x", "y", "z"], skipna=True, min_count=min_count)

xarray/tests/test_duck_array_ops.py:608: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/common.py:46: in wrapped_func
    return self.reduce(func, dim, axis, skipna=skipna, **kwargs)
xarray/core/dataarray.py:2347: in reduce
    var = self.variable.reduce(func, dim, axis, keep_attrs, keepdims, **kwargs)
xarray/core/variable.py:1640: in reduce
    data = func(input_data, axis=axis, **kwargs)
xarray/core/duck_array_ops.py:335: in f
    return func(values, axis=axis, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = array([[[ 1.76405235,  0.40015721,  0.97873798,  0.        ],
        [ 1.86755799, -0.97727788,  0.95008842, -0.15135...  [ 0.        , -0.58126848, -1.63263453,  0.        ],
        [-1.17915793,  1.30142807,  0.89526027,  1.37496407]]])
axis = (0, 1, 2), dtype = None, out = None, min_count = 3

    def nansum(a, axis=None, dtype=None, out=None, min_count=None):
        a, mask = _replace_nan(a, 0)
        result = _dask_or_eager_func("sum")(a, axis=axis, dtype=dtype)
        if min_count is not None:
            if isinstance(axis, (tuple, list)):
                axis = tuple(range(len(a.shape))) if axis is None else axis
                valid_elements = np.take(a.shape, axis).prod()
            else:
                valid_elements = a.shape[axis]
>           return _maybe_null_out(result, axis, mask, min_count, valid_elements)
E           TypeError: _maybe_null_out() takes from 3 to 4 positional arguments but 5 were given

xarray/core/nanops.py:120: TypeError
_______________________ test_min_count_nd[sum-False-int] _______________________

dtype = <class 'int'>, dask = False, func = 'sum'

    @pytest.mark.parametrize("dtype", [float, int, np.float32, np.bool_])
    @pytest.mark.parametrize("dask", [False, True])
    @pytest.mark.parametrize("func", ["sum", "prod"])
    def test_min_count_nd(dtype, dask, func):
        if dask and not has_dask:
            pytest.skip("requires dask")
    
        min_count = 3
        dim_num = 3
        da = construct_dataarray(dim_num, dtype, contains_nan=True, dask=dask)
>       actual = getattr(da, func)(dim=["x", "y", "z"], skipna=True, min_count=min_count)

xarray/tests/test_duck_array_ops.py:608: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/common.py:46: in wrapped_func
    return self.reduce(func, dim, axis, skipna=skipna, **kwargs)
xarray/core/dataarray.py:2347: in reduce
    var = self.variable.reduce(func, dim, axis, keep_attrs, keepdims, **kwargs)
xarray/core/variable.py:1640: in reduce
    data = func(input_data, axis=axis, **kwargs)
xarray/core/duck_array_ops.py:335: in f
    return func(values, axis=axis, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = array([[[5., 0., 3., 0.],
        [7., 9., 3., 5.],
        [2., 4., 7., 6.],
        [8., 8., 1., 6.],
        [7., 7... 6., 0., 8.],
        [0., 7., 6., 0.],
        [9., 6., 5., 2.],
        [7., 1., 9., 0.],
        [0., 5., 6., 4.]]])
axis = (0, 1, 2), dtype = None, out = None, min_count = 3

    def nansum(a, axis=None, dtype=None, out=None, min_count=None):
        a, mask = _replace_nan(a, 0)
        result = _dask_or_eager_func("sum")(a, axis=axis, dtype=dtype)
        if min_count is not None:
            if isinstance(axis, (tuple, list)):
                axis = tuple(range(len(a.shape))) if axis is None else axis
                valid_elements = np.take(a.shape, axis).prod()
            else:
                valid_elements = a.shape[axis]
>           return _maybe_null_out(result, axis, mask, min_count, valid_elements)
E           TypeError: _maybe_null_out() takes from 3 to 4 positional arguments but 5 were given

xarray/core/nanops.py:120: TypeError
_____________________ test_min_count_nd[sum-False-float32] _____________________

dtype = <class 'numpy.float32'>, dask = False, func = 'sum'

    @pytest.mark.parametrize("dtype", [float, int, np.float32, np.bool_])
    @pytest.mark.parametrize("dask", [False, True])
    @pytest.mark.parametrize("func", ["sum", "prod"])
    def test_min_count_nd(dtype, dask, func):
        if dask and not has_dask:
            pytest.skip("requires dask")
    
        min_count = 3
        dim_num = 3
        da = construct_dataarray(dim_num, dtype, contains_nan=True, dask=dask)
>       actual = getattr(da, func)(dim=["x", "y", "z"], skipna=True, min_count=min_count)

xarray/tests/test_duck_array_ops.py:608: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/common.py:46: in wrapped_func
    return self.reduce(func, dim, axis, skipna=skipna, **kwargs)
xarray/core/dataarray.py:2347: in reduce
    var = self.variable.reduce(func, dim, axis, keep_attrs, keepdims, **kwargs)
xarray/core/variable.py:1640: in reduce
    data = func(input_data, axis=axis, **kwargs)
xarray/core/duck_array_ops.py:335: in f
    return func(values, axis=axis, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = array([[[ 1.7640524 ,  0.4001572 ,  0.978738  ,  0.        ],
        [ 1.867558  , -0.9772779 ,  0.95008844, -0.15135...12685 , -1.6326345 ,  0.        ],
        [-1.179158  ,  1.3014281 ,  0.8952603 ,  1.3749641 ]]],
      dtype=float32)
axis = (0, 1, 2), dtype = None, out = None, min_count = 3

    def nansum(a, axis=None, dtype=None, out=None, min_count=None):
        a, mask = _replace_nan(a, 0)
        result = _dask_or_eager_func("sum")(a, axis=axis, dtype=dtype)
        if min_count is not None:
            if isinstance(axis, (tuple, list)):
                axis = tuple(range(len(a.shape))) if axis is None else axis
                valid_elements = np.take(a.shape, axis).prod()
            else:
                valid_elements = a.shape[axis]
>           return _maybe_null_out(result, axis, mask, min_count, valid_elements)
E           TypeError: _maybe_null_out() takes from 3 to 4 positional arguments but 5 were given

xarray/core/nanops.py:120: TypeError
______________________ test_min_count_nd[sum-False-bool_] ______________________

dtype = <class 'numpy.bool_'>, dask = False, func = 'sum'

    @pytest.mark.parametrize("dtype", [float, int, np.float32, np.bool_])
    @pytest.mark.parametrize("dask", [False, True])
    @pytest.mark.parametrize("func", ["sum", "prod"])
    def test_min_count_nd(dtype, dask, func):
        if dask and not has_dask:
            pytest.skip("requires dask")
    
        min_count = 3
        dim_num = 3
        da = construct_dataarray(dim_num, dtype, contains_nan=True, dask=dask)
>       actual = getattr(da, func)(dim=["x", "y", "z"], skipna=True, min_count=min_count)

xarray/tests/test_duck_array_ops.py:608: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/common.py:46: in wrapped_func
    return self.reduce(func, dim, axis, skipna=skipna, **kwargs)
xarray/core/dataarray.py:2347: in reduce
    var = self.variable.reduce(func, dim, axis, keep_attrs, keepdims, **kwargs)
xarray/core/variable.py:1640: in reduce
    data = func(input_data, axis=axis, **kwargs)
xarray/core/duck_array_ops.py:335: in f
    return func(values, axis=axis, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = array([[[False, False, False, False],
        [False, False, False, False],
        [False, 0, False, False],
        ...  [False, False, False, False],
        [False, False, False, False],
        [False, False, 0, False]]], dtype=object)
axis = (0, 1, 2), dtype = None, out = None, min_count = 3

    def nansum(a, axis=None, dtype=None, out=None, min_count=None):
        a, mask = _replace_nan(a, 0)
        result = _dask_or_eager_func("sum")(a, axis=axis, dtype=dtype)
        if min_count is not None:
            if isinstance(axis, (tuple, list)):
                axis = tuple(range(len(a.shape))) if axis is None else axis
                valid_elements = np.take(a.shape, axis).prod()
            else:
                valid_elements = a.shape[axis]
>           return _maybe_null_out(result, axis, mask, min_count, valid_elements)
E           TypeError: _maybe_null_out() takes from 3 to 4 positional arguments but 5 were given

xarray/core/nanops.py:120: TypeError
______________________ test_min_count_nd[sum-True-float] _______________________

dtype = <class 'float'>, dask = True, func = 'sum'

    @pytest.mark.parametrize("dtype", [float, int, np.float32, np.bool_])
    @pytest.mark.parametrize("dask", [False, True])
    @pytest.mark.parametrize("func", ["sum", "prod"])
    def test_min_count_nd(dtype, dask, func):
        if dask and not has_dask:
            pytest.skip("requires dask")
    
        min_count = 3
        dim_num = 3
        da = construct_dataarray(dim_num, dtype, contains_nan=True, dask=dask)
>       actual = getattr(da, func)(dim=["x", "y", "z"], skipna=True, min_count=min_count)

xarray/tests/test_duck_array_ops.py:608: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/common.py:46: in wrapped_func
    return self.reduce(func, dim, axis, skipna=skipna, **kwargs)
xarray/core/dataarray.py:2347: in reduce
    var = self.variable.reduce(func, dim, axis, keep_attrs, keepdims, **kwargs)
xarray/core/variable.py:1640: in reduce
    data = func(input_data, axis=axis, **kwargs)
xarray/core/duck_array_ops.py:335: in f
    return func(values, axis=axis, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = dask.array<where, shape=(16, 8, 4), dtype=float64, chunksize=(4, 4, 4), chunktype=numpy.ndarray>
axis = (0, 1, 2), dtype = None, out = None, min_count = 3

    def nansum(a, axis=None, dtype=None, out=None, min_count=None):
        a, mask = _replace_nan(a, 0)
        result = _dask_or_eager_func("sum")(a, axis=axis, dtype=dtype)
        if min_count is not None:
            if isinstance(axis, (tuple, list)):
                axis = tuple(range(len(a.shape))) if axis is None else axis
                valid_elements = np.take(a.shape, axis).prod()
            else:
                valid_elements = a.shape[axis]
>           return _maybe_null_out(result, axis, mask, min_count, valid_elements)
E           TypeError: _maybe_null_out() takes from 3 to 4 positional arguments but 5 were given

xarray/core/nanops.py:120: TypeError
_______________________ test_min_count_nd[sum-True-int] ________________________

dtype = <class 'int'>, dask = True, func = 'sum'

    @pytest.mark.parametrize("dtype", [float, int, np.float32, np.bool_])
    @pytest.mark.parametrize("dask", [False, True])
    @pytest.mark.parametrize("func", ["sum", "prod"])
    def test_min_count_nd(dtype, dask, func):
        if dask and not has_dask:
            pytest.skip("requires dask")
    
        min_count = 3
        dim_num = 3
        da = construct_dataarray(dim_num, dtype, contains_nan=True, dask=dask)
>       actual = getattr(da, func)(dim=["x", "y", "z"], skipna=True, min_count=min_count)

xarray/tests/test_duck_array_ops.py:608: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/common.py:46: in wrapped_func
    return self.reduce(func, dim, axis, skipna=skipna, **kwargs)
xarray/core/dataarray.py:2347: in reduce
    var = self.variable.reduce(func, dim, axis, keep_attrs, keepdims, **kwargs)
xarray/core/variable.py:1640: in reduce
    data = func(input_data, axis=axis, **kwargs)
xarray/core/duck_array_ops.py:335: in f
    return func(values, axis=axis, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = dask.array<where, shape=(16, 8, 4), dtype=float64, chunksize=(4, 4, 4), chunktype=numpy.ndarray>
axis = (0, 1, 2), dtype = None, out = None, min_count = 3

    def nansum(a, axis=None, dtype=None, out=None, min_count=None):
        a, mask = _replace_nan(a, 0)
        result = _dask_or_eager_func("sum")(a, axis=axis, dtype=dtype)
        if min_count is not None:
            if isinstance(axis, (tuple, list)):
                axis = tuple(range(len(a.shape))) if axis is None else axis
                valid_elements = np.take(a.shape, axis).prod()
            else:
                valid_elements = a.shape[axis]
>           return _maybe_null_out(result, axis, mask, min_count, valid_elements)
E           TypeError: _maybe_null_out() takes from 3 to 4 positional arguments but 5 were given

xarray/core/nanops.py:120: TypeError
_____________________ test_min_count_nd[sum-True-float32] ______________________

dtype = <class 'numpy.float32'>, dask = True, func = 'sum'

    @pytest.mark.parametrize("dtype", [float, int, np.float32, np.bool_])
    @pytest.mark.parametrize("dask", [False, True])
    @pytest.mark.parametrize("func", ["sum", "prod"])
    def test_min_count_nd(dtype, dask, func):
        if dask and not has_dask:
            pytest.skip("requires dask")
    
        min_count = 3
        dim_num = 3
        da = construct_dataarray(dim_num, dtype, contains_nan=True, dask=dask)
>       actual = getattr(da, func)(dim=["x", "y", "z"], skipna=True, min_count=min_count)

xarray/tests/test_duck_array_ops.py:608: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/common.py:46: in wrapped_func
    return self.reduce(func, dim, axis, skipna=skipna, **kwargs)
xarray/core/dataarray.py:2347: in reduce
    var = self.variable.reduce(func, dim, axis, keep_attrs, keepdims, **kwargs)
xarray/core/variable.py:1640: in reduce
    data = func(input_data, axis=axis, **kwargs)
xarray/core/duck_array_ops.py:335: in f
    return func(values, axis=axis, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = dask.array<where, shape=(16, 8, 4), dtype=float32, chunksize=(4, 4, 4), chunktype=numpy.ndarray>
axis = (0, 1, 2), dtype = None, out = None, min_count = 3

    def nansum(a, axis=None, dtype=None, out=None, min_count=None):
        a, mask = _replace_nan(a, 0)
        result = _dask_or_eager_func("sum")(a, axis=axis, dtype=dtype)
        if min_count is not None:
            if isinstance(axis, (tuple, list)):
                axis = tuple(range(len(a.shape))) if axis is None else axis
                valid_elements = np.take(a.shape, axis).prod()
            else:
                valid_elements = a.shape[axis]
>           return _maybe_null_out(result, axis, mask, min_count, valid_elements)
E           TypeError: _maybe_null_out() takes from 3 to 4 positional arguments but 5 were given

xarray/core/nanops.py:120: TypeError
______________________ test_min_count_nd[sum-True-bool_] _______________________

dtype = <class 'numpy.bool_'>, dask = True, func = 'sum'

    @pytest.mark.parametrize("dtype", [float, int, np.float32, np.bool_])
    @pytest.mark.parametrize("dask", [False, True])
    @pytest.mark.parametrize("func", ["sum", "prod"])
    def test_min_count_nd(dtype, dask, func):
        if dask and not has_dask:
            pytest.skip("requires dask")
    
        min_count = 3
        dim_num = 3
        da = construct_dataarray(dim_num, dtype, contains_nan=True, dask=dask)
>       actual = getattr(da, func)(dim=["x", "y", "z"], skipna=True, min_count=min_count)

xarray/tests/test_duck_array_ops.py:608: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/common.py:46: in wrapped_func
    return self.reduce(func, dim, axis, skipna=skipna, **kwargs)
xarray/core/dataarray.py:2347: in reduce
    var = self.variable.reduce(func, dim, axis, keep_attrs, keepdims, **kwargs)
xarray/core/variable.py:1640: in reduce
    data = func(input_data, axis=axis, **kwargs)
xarray/core/duck_array_ops.py:335: in f
    return func(values, axis=axis, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = dask.array<where, shape=(16, 8, 4), dtype=object, chunksize=(4, 4, 4), chunktype=numpy.ndarray>
axis = (0, 1, 2), dtype = None, out = None, min_count = 3

    def nansum(a, axis=None, dtype=None, out=None, min_count=None):
        a, mask = _replace_nan(a, 0)
        result = _dask_or_eager_func("sum")(a, axis=axis, dtype=dtype)
        if min_count is not None:
            if isinstance(axis, (tuple, list)):
                axis = tuple(range(len(a.shape))) if axis is None else axis
                valid_elements = np.take(a.shape, axis).prod()
            else:
                valid_elements = a.shape[axis]
>           return _maybe_null_out(result, axis, mask, min_count, valid_elements)
E           TypeError: _maybe_null_out() takes from 3 to 4 positional arguments but 5 were given

xarray/core/nanops.py:120: TypeError
_____________________ test_min_count_nd[prod-False-float] ______________________

dtype = <class 'float'>, dask = False, func = 'prod'

    @pytest.mark.parametrize("dtype", [float, int, np.float32, np.bool_])
    @pytest.mark.parametrize("dask", [False, True])
    @pytest.mark.parametrize("func", ["sum", "prod"])
    def test_min_count_nd(dtype, dask, func):
        if dask and not has_dask:
            pytest.skip("requires dask")
    
        min_count = 3
        dim_num = 3
        da = construct_dataarray(dim_num, dtype, contains_nan=True, dask=dask)
>       actual = getattr(da, func)(dim=["x", "y", "z"], skipna=True, min_count=min_count)

xarray/tests/test_duck_array_ops.py:608: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/common.py:46: in wrapped_func
    return self.reduce(func, dim, axis, skipna=skipna, **kwargs)
xarray/core/dataarray.py:2347: in reduce
    var = self.variable.reduce(func, dim, axis, keep_attrs, keepdims, **kwargs)
xarray/core/variable.py:1640: in reduce
    data = func(input_data, axis=axis, **kwargs)
xarray/core/duck_array_ops.py:335: in f
    return func(values, axis=axis, **kwargs)
xarray/core/nanops.py:190: in nanprod
    return _maybe_null_out(result, axis, mask, min_count)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

result = 3.272935136334528e-109, axis = (0, 1, 2)
mask = array([[[False, False, False,  True],
        [False, False, False, False],
        [False, False, False,  True],
    ...e],
        [False, False, False, False],
        [ True, False, False,  True],
        [False, False, False, False]]])
min_count = 3

    def _maybe_null_out(result, axis, mask, min_count=1):
        """
        xarray version of pandas.core.nanops._maybe_null_out
        """
        if hasattr(axis, "__len__"):  # if tuple or list
>           raise ValueError(
                "min_count is not available for reduction with more than one dimensions."
            )
E           ValueError: min_count is not available for reduction with more than one dimensions.

xarray/core/nanops.py:30: ValueError
______________________ test_min_count_nd[prod-False-int] _______________________

dtype = <class 'int'>, dask = False, func = 'prod'

    @pytest.mark.parametrize("dtype", [float, int, np.float32, np.bool_])
    @pytest.mark.parametrize("dask", [False, True])
    @pytest.mark.parametrize("func", ["sum", "prod"])
    def test_min_count_nd(dtype, dask, func):
        if dask and not has_dask:
            pytest.skip("requires dask")
    
        min_count = 3
        dim_num = 3
        da = construct_dataarray(dim_num, dtype, contains_nan=True, dask=dask)
>       actual = getattr(da, func)(dim=["x", "y", "z"], skipna=True, min_count=min_count)

xarray/tests/test_duck_array_ops.py:608: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/common.py:46: in wrapped_func
    return self.reduce(func, dim, axis, skipna=skipna, **kwargs)
xarray/core/dataarray.py:2347: in reduce
    var = self.variable.reduce(func, dim, axis, keep_attrs, keepdims, **kwargs)
xarray/core/variable.py:1640: in reduce
    data = func(input_data, axis=axis, **kwargs)
xarray/core/duck_array_ops.py:335: in f
    return func(values, axis=axis, **kwargs)
xarray/core/nanops.py:190: in nanprod
    return _maybe_null_out(result, axis, mask, min_count)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

result = 0.0, axis = (0, 1, 2)
mask = array([[[False, False, False,  True],
        [False, False, False, False],
        [False, False, False, False],
    ...e],
        [False, False, False, False],
        [False, False, False,  True],
        [ True, False, False, False]]])
min_count = 3

    def _maybe_null_out(result, axis, mask, min_count=1):
        """
        xarray version of pandas.core.nanops._maybe_null_out
        """
        if hasattr(axis, "__len__"):  # if tuple or list
>           raise ValueError(
                "min_count is not available for reduction with more than one dimensions."
            )
E           ValueError: min_count is not available for reduction with more than one dimensions.

xarray/core/nanops.py:30: ValueError
____________________ test_min_count_nd[prod-False-float32] _____________________

dtype = <class 'numpy.float32'>, dask = False, func = 'prod'

    @pytest.mark.parametrize("dtype", [float, int, np.float32, np.bool_])
    @pytest.mark.parametrize("dask", [False, True])
    @pytest.mark.parametrize("func", ["sum", "prod"])
    def test_min_count_nd(dtype, dask, func):
        if dask and not has_dask:
            pytest.skip("requires dask")
    
        min_count = 3
        dim_num = 3
        da = construct_dataarray(dim_num, dtype, contains_nan=True, dask=dask)
>       actual = getattr(da, func)(dim=["x", "y", "z"], skipna=True, min_count=min_count)

xarray/tests/test_duck_array_ops.py:608: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/common.py:46: in wrapped_func
    return self.reduce(func, dim, axis, skipna=skipna, **kwargs)
xarray/core/dataarray.py:2347: in reduce
    var = self.variable.reduce(func, dim, axis, keep_attrs, keepdims, **kwargs)
xarray/core/variable.py:1640: in reduce
    data = func(input_data, axis=axis, **kwargs)
xarray/core/duck_array_ops.py:335: in f
    return func(values, axis=axis, **kwargs)
xarray/core/nanops.py:190: in nanprod
    return _maybe_null_out(result, axis, mask, min_count)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

result = 0.0, axis = (0, 1, 2)
mask = array([[[False, False, False,  True],
        [False, False, False, False],
        [False, False, False,  True],
    ...e],
        [False, False, False, False],
        [ True, False, False,  True],
        [False, False, False, False]]])
min_count = 3

    def _maybe_null_out(result, axis, mask, min_count=1):
        """
        xarray version of pandas.core.nanops._maybe_null_out
        """
        if hasattr(axis, "__len__"):  # if tuple or list
>           raise ValueError(
                "min_count is not available for reduction with more than one dimensions."
            )
E           ValueError: min_count is not available for reduction with more than one dimensions.

xarray/core/nanops.py:30: ValueError
_____________________ test_min_count_nd[prod-False-bool_] ______________________

dtype = <class 'numpy.bool_'>, dask = False, func = 'prod'

    @pytest.mark.parametrize("dtype", [float, int, np.float32, np.bool_])
    @pytest.mark.parametrize("dask", [False, True])
    @pytest.mark.parametrize("func", ["sum", "prod"])
    def test_min_count_nd(dtype, dask, func):
        if dask and not has_dask:
            pytest.skip("requires dask")
    
        min_count = 3
        dim_num = 3
        da = construct_dataarray(dim_num, dtype, contains_nan=True, dask=dask)
>       actual = getattr(da, func)(dim=["x", "y", "z"], skipna=True, min_count=min_count)

xarray/tests/test_duck_array_ops.py:608: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/common.py:46: in wrapped_func
    return self.reduce(func, dim, axis, skipna=skipna, **kwargs)
xarray/core/dataarray.py:2347: in reduce
    var = self.variable.reduce(func, dim, axis, keep_attrs, keepdims, **kwargs)
xarray/core/variable.py:1640: in reduce
    data = func(input_data, axis=axis, **kwargs)
xarray/core/duck_array_ops.py:335: in f
    return func(values, axis=axis, **kwargs)
xarray/core/nanops.py:190: in nanprod
    return _maybe_null_out(result, axis, mask, min_count)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

result = 0, axis = (0, 1, 2)
mask = array([[[False, False, False, False],
        [False, False, False, False],
        [False,  True, False, False],
    ...e],
        [False, False, False, False],
        [False, False, False, False],
        [False, False,  True, False]]])
min_count = 3

    def _maybe_null_out(result, axis, mask, min_count=1):
        """
        xarray version of pandas.core.nanops._maybe_null_out
        """
        if hasattr(axis, "__len__"):  # if tuple or list
>           raise ValueError(
                "min_count is not available for reduction with more than one dimensions."
            )
E           ValueError: min_count is not available for reduction with more than one dimensions.

xarray/core/nanops.py:30: ValueError
______________________ test_min_count_nd[prod-True-float] ______________________

dtype = <class 'float'>, dask = True, func = 'prod'

    @pytest.mark.parametrize("dtype", [float, int, np.float32, np.bool_])
    @pytest.mark.parametrize("dask", [False, True])
    @pytest.mark.parametrize("func", ["sum", "prod"])
    def test_min_count_nd(dtype, dask, func):
        if dask and not has_dask:
            pytest.skip("requires dask")
    
        min_count = 3
        dim_num = 3
        da = construct_dataarray(dim_num, dtype, contains_nan=True, dask=dask)
>       actual = getattr(da, func)(dim=["x", "y", "z"], skipna=True, min_count=min_count)

xarray/tests/test_duck_array_ops.py:608: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/common.py:46: in wrapped_func
    return self.reduce(func, dim, axis, skipna=skipna, **kwargs)
xarray/core/dataarray.py:2347: in reduce
    var = self.variable.reduce(func, dim, axis, keep_attrs, keepdims, **kwargs)
xarray/core/variable.py:1640: in reduce
    data = func(input_data, axis=axis, **kwargs)
xarray/core/duck_array_ops.py:335: in f
    return func(values, axis=axis, **kwargs)
xarray/core/nanops.py:190: in nanprod
    return _maybe_null_out(result, axis, mask, min_count)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

result = dask.array<prod-aggregate, shape=(), dtype=float64, chunksize=(), chunktype=numpy.ndarray>
axis = (0, 1, 2)
mask = dask.array<isnan, shape=(16, 8, 4), dtype=bool, chunksize=(4, 4, 4), chunktype=numpy.ndarray>
min_count = 3

    def _maybe_null_out(result, axis, mask, min_count=1):
        """
        xarray version of pandas.core.nanops._maybe_null_out
        """
        if hasattr(axis, "__len__"):  # if tuple or list
>           raise ValueError(
                "min_count is not available for reduction with more than one dimensions."
            )
E           ValueError: min_count is not available for reduction with more than one dimensions.

xarray/core/nanops.py:30: ValueError
_______________________ test_min_count_nd[prod-True-int] _______________________

dtype = <class 'int'>, dask = True, func = 'prod'

    @pytest.mark.parametrize("dtype", [float, int, np.float32, np.bool_])
    @pytest.mark.parametrize("dask", [False, True])
    @pytest.mark.parametrize("func", ["sum", "prod"])
    def test_min_count_nd(dtype, dask, func):
        if dask and not has_dask:
            pytest.skip("requires dask")
    
        min_count = 3
        dim_num = 3
        da = construct_dataarray(dim_num, dtype, contains_nan=True, dask=dask)
>       actual = getattr(da, func)(dim=["x", "y", "z"], skipna=True, min_count=min_count)

xarray/tests/test_duck_array_ops.py:608: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/common.py:46: in wrapped_func
    return self.reduce(func, dim, axis, skipna=skipna, **kwargs)
xarray/core/dataarray.py:2347: in reduce
    var = self.variable.reduce(func, dim, axis, keep_attrs, keepdims, **kwargs)
xarray/core/variable.py:1640: in reduce
    data = func(input_data, axis=axis, **kwargs)
xarray/core/duck_array_ops.py:335: in f
    return func(values, axis=axis, **kwargs)
xarray/core/nanops.py:190: in nanprod
    return _maybe_null_out(result, axis, mask, min_count)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

result = dask.array<prod-aggregate, shape=(), dtype=float64, chunksize=(), chunktype=numpy.ndarray>
axis = (0, 1, 2)
mask = dask.array<isnan, shape=(16, 8, 4), dtype=bool, chunksize=(4, 4, 4), chunktype=numpy.ndarray>
min_count = 3

    def _maybe_null_out(result, axis, mask, min_count=1):
        """
        xarray version of pandas.core.nanops._maybe_null_out
        """
        if hasattr(axis, "__len__"):  # if tuple or list
>           raise ValueError(
                "min_count is not available for reduction with more than one dimensions."
            )
E           ValueError: min_count is not available for reduction with more than one dimensions.

xarray/core/nanops.py:30: ValueError
_____________________ test_min_count_nd[prod-True-float32] _____________________

dtype = <class 'numpy.float32'>, dask = True, func = 'prod'

    @pytest.mark.parametrize("dtype", [float, int, np.float32, np.bool_])
    @pytest.mark.parametrize("dask", [False, True])
    @pytest.mark.parametrize("func", ["sum", "prod"])
    def test_min_count_nd(dtype, dask, func):
        if dask and not has_dask:
            pytest.skip("requires dask")
    
        min_count = 3
        dim_num = 3
        da = construct_dataarray(dim_num, dtype, contains_nan=True, dask=dask)
>       actual = getattr(da, func)(dim=["x", "y", "z"], skipna=True, min_count=min_count)

xarray/tests/test_duck_array_ops.py:608: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/common.py:46: in wrapped_func
    return self.reduce(func, dim, axis, skipna=skipna, **kwargs)
xarray/core/dataarray.py:2347: in reduce
    var = self.variable.reduce(func, dim, axis, keep_attrs, keepdims, **kwargs)
xarray/core/variable.py:1640: in reduce
    data = func(input_data, axis=axis, **kwargs)
xarray/core/duck_array_ops.py:335: in f
    return func(values, axis=axis, **kwargs)
xarray/core/nanops.py:190: in nanprod
    return _maybe_null_out(result, axis, mask, min_count)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

result = dask.array<prod-aggregate, shape=(), dtype=float32, chunksize=(), chunktype=numpy.ndarray>
axis = (0, 1, 2)
mask = dask.array<isnan, shape=(16, 8, 4), dtype=bool, chunksize=(4, 4, 4), chunktype=numpy.ndarray>
min_count = 3

    def _maybe_null_out(result, axis, mask, min_count=1):
        """
        xarray version of pandas.core.nanops._maybe_null_out
        """
        if hasattr(axis, "__len__"):  # if tuple or list
>           raise ValueError(
                "min_count is not available for reduction with more than one dimensions."
            )
E           ValueError: min_count is not available for reduction with more than one dimensions.

xarray/core/nanops.py:30: ValueError
______________________ test_min_count_nd[prod-True-bool_] ______________________

dtype = <class 'numpy.bool_'>, dask = True, func = 'prod'

    @pytest.mark.parametrize("dtype", [float, int, np.float32, np.bool_])
    @pytest.mark.parametrize("dask", [False, True])
    @pytest.mark.parametrize("func", ["sum", "prod"])
    def test_min_count_nd(dtype, dask, func):
        if dask and not has_dask:
            pytest.skip("requires dask")
    
        min_count = 3
        dim_num = 3
        da = construct_dataarray(dim_num, dtype, contains_nan=True, dask=dask)
>       actual = getattr(da, func)(dim=["x", "y", "z"], skipna=True, min_count=min_count)

xarray/tests/test_duck_array_ops.py:608: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/common.py:46: in wrapped_func
    return self.reduce(func, dim, axis, skipna=skipna, **kwargs)
xarray/core/dataarray.py:2347: in reduce
    var = self.variable.reduce(func, dim, axis, keep_attrs, keepdims, **kwargs)
xarray/core/variable.py:1640: in reduce
    data = func(input_data, axis=axis, **kwargs)
xarray/core/duck_array_ops.py:335: in f
    return func(values, axis=axis, **kwargs)
xarray/core/nanops.py:190: in nanprod
    return _maybe_null_out(result, axis, mask, min_count)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

result = dask.array<prod-aggregate, shape=(), dtype=object, chunksize=(), chunktype=numpy.ndarray>
axis = (0, 1, 2)
mask = dask.array<_asarray_isnull, shape=(16, 8, 4), dtype=bool, chunksize=(4, 4, 4), chunktype=numpy.ndarray>
min_count = 3

    def _maybe_null_out(result, axis, mask, min_count=1):
        """
        xarray version of pandas.core.nanops._maybe_null_out
        """
        if hasattr(axis, "__len__"):  # if tuple or list
>           raise ValueError(
                "min_count is not available for reduction with more than one dimensions."
            )
E           ValueError: min_count is not available for reduction with more than one dimensions.

xarray/core/nanops.py:30: ValueError
_________________________ test_min_count_dataset[sum] __________________________

func = 'sum'

    @pytest.mark.parametrize("func", ["sum", "prod"])
    def test_min_count_dataset(func):
        da = construct_dataarray(2, dtype=float, contains_nan=True, dask=False)
        ds = Dataset({"var1": da}, coords={"scalar": 0})
>       actual = getattr(ds, func)(dim="x", skipna=True, min_count=3)["var1"]

xarray/tests/test_duck_array_ops.py:620: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
xarray/core/common.py:83: in wrapped_func
    return self.reduce(
xarray/core/dataset.py:4312: in reduce
    variables[name] = var.reduce(
xarray/core/variable.py:1640: in reduce
    data = func(input_data, axis=axis, **kwargs)
xarray/core/duck_array_ops.py:335: in f
    return func(values, axis=axis, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = array([[ 0.        ,  0.40015721,  0.97873798,  0.        ,  1.86755799,
         0.        ,  0.95008842, -0.15135721...     [ 0.37642553, -1.09940079,  0.29823817,  1.3263859 , -0.69456786,
        -0.14963454, -0.43515355,  0.        ]])
axis = 0, dtype = None, out = None, min_count = 3

    def nansum(a, axis=None, dtype=None, out=None, min_count=None):
        a, mask = _replace_nan(a, 0)
        result = _dask_or_eager_func("sum")(a, axis=axis, dtype=dtype)
        if min_count is not None:
            if isinstance(axis, (tuple, list)):
                axis = tuple(range(len(a.shape))) if axis is None else axis
                valid_elements = np.take(a.shape, axis).prod()
            else:
                valid_elements = a.shape[axis]
>           return _maybe_null_out(result, axis, mask, min_count, valid_elements)
E           TypeError: _maybe_null_out() takes from 3 to 4 positional arguments but 5 were given

xarray/core/nanops.py:120: TypeError
=============================== warnings summary ===============================
xarray/__init__.py:1
  /testbed/xarray/__init__.py:1: DeprecationWarning: pkg_resources is deprecated as an API. See https://setuptools.pypa.io/en/latest/pkg_resources.html
    import pkg_resources

xarray/core/dask_array_compat.py:16
xarray/core/dask_array_compat.py:16
  /testbed/xarray/core/dask_array_compat.py:16: DeprecationWarning: distutils Version classes are deprecated. Use packaging.version instead.
    if LooseVersion(dask_version) >= LooseVersion("2.0.0"):

xarray/core/dask_array_compat.py:149
xarray/core/dask_array_compat.py:149
  /testbed/xarray/core/dask_array_compat.py:149: DeprecationWarning: distutils Version classes are deprecated. Use packaging.version instead.
    if LooseVersion(dask_version) >= LooseVersion("2.8.1"):

xarray/core/dask_array_compat.py:186
xarray/core/dask_array_compat.py:186
  /testbed/xarray/core/dask_array_compat.py:186: DeprecationWarning: distutils Version classes are deprecated. Use packaging.version instead.
    if LooseVersion(dask_version) > LooseVersion("2.9.0"):

xarray/core/pdcompat.py:45
  /testbed/xarray/core/pdcompat.py:45: DeprecationWarning: distutils Version classes are deprecated. Use packaging.version instead.
    if LooseVersion(pd.__version__) < "0.25.0":

../opt/miniconda3/envs/testbed/lib/python3.10/site-packages/setuptools/_distutils/version.py:345
xarray/tests/test_duck_array_ops.py::test_cftime_datetime_mean_dask_error
  /opt/miniconda3/envs/testbed/lib/python3.10/site-packages/setuptools/_distutils/version.py:345: DeprecationWarning: distutils Version classes are deprecated. Use packaging.version instead.
    other = LooseVersion(other)

xarray/tests/__init__.py:58
xarray/tests/__init__.py:58
  /testbed/xarray/tests/__init__.py:58: DeprecationWarning: distutils Version classes are deprecated. Use packaging.version instead.
    return version.LooseVersion(vstring)

xarray/tests/test_duck_array_ops.py::test_cftime_datetime_mean
xarray/tests/test_duck_array_ops.py::test_cftime_datetime_mean
xarray/tests/test_duck_array_ops.py::test_cftime_datetime_mean_dask_error
xarray/tests/test_duck_array_ops.py::test_cftime_datetime_mean_dask_error
xarray/tests/test_duck_array_ops.py::test_datetime_to_numeric_cftime
xarray/tests/test_duck_array_ops.py::test_datetime_to_numeric_cftime
xarray/tests/test_duck_array_ops.py::test_datetime_to_numeric_potential_overflow
xarray/tests/test_duck_array_ops.py::test_datetime_to_numeric_potential_overflow
  /testbed/xarray/coding/cftimeindex.py:122: DeprecationWarning: distutils Version classes are deprecated. Use packaging.version instead.
    if LooseVersion(cftime.__version__) < LooseVersion("1.0.4"):

xarray/tests/test_duck_array_ops.py::test_cftime_datetime_mean_dask_error
  /testbed/xarray/core/variable.py:1043: DeprecationWarning: distutils Version classes are deprecated. Use packaging.version instead.
    if LooseVersion(dask.__version__) < "2.0.0":

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
==================================== PASSES ====================================
=========================== short test summary info ============================
PASSED xarray/tests/test_duck_array_ops.py::TestOps::test_first
PASSED xarray/tests/test_duck_array_ops.py::TestOps::test_last
PASSED xarray/tests/test_duck_array_ops.py::TestOps::test_count
PASSED xarray/tests/test_duck_array_ops.py::TestOps::test_where_type_promotion
PASSED xarray/tests/test_duck_array_ops.py::TestOps::test_stack_type_promotion
PASSED xarray/tests/test_duck_array_ops.py::TestOps::test_concatenate_type_promotion
PASSED xarray/tests/test_duck_array_ops.py::TestOps::test_all_nan_arrays
PASSED xarray/tests/test_duck_array_ops.py::test_cumsum_1d
PASSED xarray/tests/test_duck_array_ops.py::test_cumsum_2d
PASSED xarray/tests/test_duck_array_ops.py::test_cumprod_2d
PASSED xarray/tests/test_duck_array_ops.py::TestArrayNotNullEquiv::test_equal[arr10-arr20]
PASSED xarray/tests/test_duck_array_ops.py::TestArrayNotNullEquiv::test_equal[arr11-arr21]
PASSED xarray/tests/test_duck_array_ops.py::TestArrayNotNullEquiv::test_equal[arr12-arr22]
PASSED xarray/tests/test_duck_array_ops.py::TestArrayNotNullEquiv::test_some_not_equal
PASSED xarray/tests/test_duck_array_ops.py::TestArrayNotNullEquiv::test_wrong_shape
PASSED xarray/tests/test_duck_array_ops.py::TestArrayNotNullEquiv::test_types[val10-val20-val30-null0]
PASSED xarray/tests/test_duck_array_ops.py::TestArrayNotNullEquiv::test_types[1.0-2.0-3.0-nan]
PASSED xarray/tests/test_duck_array_ops.py::TestArrayNotNullEquiv::test_types[foo-bar-baz-None]
PASSED xarray/tests/test_duck_array_ops.py::TestArrayNotNullEquiv::test_types[foo-bar-baz-nan]
PASSED xarray/tests/test_duck_array_ops.py::test_datetime_mean[False]
PASSED xarray/tests/test_duck_array_ops.py::test_datetime_mean[True]
PASSED xarray/tests/test_duck_array_ops.py::test_cftime_datetime_mean
PASSED xarray/tests/test_duck_array_ops.py::test_cftime_datetime_mean_long_time_period
PASSED xarray/tests/test_duck_array_ops.py::test_cftime_datetime_mean_dask_error
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-False-sum-False-float-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-False-sum-False-float-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-False-sum-False-int-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-False-sum-False-int-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-False-sum-False-float32-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-False-sum-False-float32-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-False-sum-False-bool_-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-False-sum-False-bool_-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-False-sum-True-float-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-False-sum-True-float-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-False-sum-True-int-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-False-sum-True-int-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-False-sum-True-float32-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-False-sum-True-float32-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-False-min-False-float-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-False-min-False-float-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-False-min-False-int-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-False-min-False-int-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-False-min-False-float32-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-False-min-False-float32-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-False-min-False-bool_-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-False-min-False-bool_-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-False-min-True-float-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-False-min-True-float-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-False-min-True-int-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-False-min-True-int-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-False-min-True-float32-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-False-min-True-float32-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-False-max-False-float-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-False-max-False-float-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-False-max-False-int-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-False-max-False-int-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-False-max-False-float32-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-False-max-False-float32-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-False-max-False-bool_-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-False-max-False-bool_-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-False-max-True-float-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-False-max-True-float-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-False-max-True-int-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-False-max-True-int-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-False-max-True-float32-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-False-max-True-float32-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-False-mean-False-float-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-False-mean-False-float-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-False-mean-False-int-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-False-mean-False-int-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-False-mean-False-float32-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-False-mean-False-float32-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-False-mean-True-float-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-False-mean-True-float-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-False-mean-True-int-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-False-mean-True-int-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-False-mean-True-float32-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-False-mean-True-float32-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-False-var-False-float-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-False-var-False-float-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-False-var-False-int-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-False-var-False-int-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-False-var-False-float32-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-False-var-False-float32-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-False-var-False-bool_-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-False-var-False-bool_-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-False-var-True-float-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-False-var-True-float-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-False-var-True-int-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-False-var-True-int-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-False-var-True-float32-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-False-var-True-float32-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-True-sum-False-float-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-True-sum-False-float-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-True-sum-False-int-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-True-sum-False-int-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-True-sum-False-float32-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-True-sum-False-float32-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-True-sum-False-bool_-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-True-sum-False-bool_-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-True-sum-True-float-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-True-sum-True-float-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-True-sum-True-int-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-True-sum-True-int-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-True-sum-True-float32-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-True-sum-True-float32-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-True-sum-True-bool_-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-True-sum-True-bool_-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-True-min-False-float-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-True-min-False-float-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-True-min-False-int-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-True-min-False-int-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-True-min-False-float32-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-True-min-False-float32-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-True-min-False-bool_-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-True-min-False-bool_-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-True-min-True-float-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-True-min-True-float-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-True-min-True-int-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-True-min-True-int-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-True-min-True-float32-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-True-min-True-float32-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-True-min-True-bool_-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-True-min-True-bool_-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-True-max-False-float-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-True-max-False-float-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-True-max-False-int-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-True-max-False-int-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-True-max-False-float32-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-True-max-False-float32-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-True-max-False-bool_-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-True-max-False-bool_-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-True-max-True-float-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-True-max-True-float-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-True-max-True-int-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-True-max-True-int-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-True-max-True-float32-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-True-max-True-float32-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-True-max-True-bool_-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-True-max-True-bool_-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-True-mean-False-float-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-True-mean-False-float-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-True-mean-False-int-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-True-mean-False-int-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-True-mean-False-float32-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-True-mean-False-float32-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-True-mean-True-float-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-True-mean-True-float-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-True-mean-True-int-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-True-mean-True-int-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-True-mean-True-float32-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-True-mean-True-float32-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-True-var-False-float-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-True-var-False-float-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-True-var-False-int-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-True-var-False-int-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-True-var-False-float32-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-True-var-False-float32-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-True-var-False-bool_-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-True-var-False-bool_-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-True-var-True-float-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-True-var-True-float-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-True-var-True-int-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-True-var-True-int-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-True-var-True-float32-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-True-var-True-float32-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-True-var-True-bool_-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[None-True-var-True-bool_-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-False-sum-False-float-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-False-sum-False-float-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-False-sum-False-int-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-False-sum-False-int-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-False-sum-False-float32-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-False-sum-False-float32-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-False-sum-False-bool_-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-False-sum-False-bool_-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-False-sum-True-float-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-False-sum-True-float-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-False-sum-True-int-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-False-sum-True-int-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-False-sum-True-float32-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-False-sum-True-float32-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-False-min-False-float-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-False-min-False-float-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-False-min-False-int-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-False-min-False-int-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-False-min-False-float32-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-False-min-False-float32-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-False-min-False-bool_-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-False-min-False-bool_-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-False-min-True-float-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-False-min-True-float-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-False-min-True-int-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-False-min-True-int-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-False-min-True-float32-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-False-min-True-float32-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-False-max-False-float-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-False-max-False-float-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-False-max-False-int-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-False-max-False-int-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-False-max-False-float32-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-False-max-False-float32-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-False-max-False-bool_-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-False-max-False-bool_-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-False-max-True-float-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-False-max-True-float-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-False-max-True-int-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-False-max-True-int-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-False-max-True-float32-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-False-max-True-float32-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-False-mean-False-float-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-False-mean-False-float-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-False-mean-False-int-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-False-mean-False-int-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-False-mean-False-float32-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-False-mean-False-float32-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-False-mean-True-float-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-False-mean-True-float-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-False-mean-True-int-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-False-mean-True-int-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-False-mean-True-float32-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-False-mean-True-float32-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-False-var-False-float-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-False-var-False-float-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-False-var-False-int-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-False-var-False-int-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-False-var-False-float32-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-False-var-False-float32-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-False-var-False-bool_-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-False-var-False-bool_-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-False-var-True-float-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-False-var-True-float-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-False-var-True-int-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-False-var-True-int-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-False-var-True-float32-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-False-var-True-float32-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-True-sum-False-float-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-True-sum-False-float-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-True-sum-False-int-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-True-sum-False-int-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-True-sum-False-float32-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-True-sum-False-float32-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-True-sum-False-bool_-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-True-sum-False-bool_-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-True-sum-True-float-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-True-sum-True-float-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-True-sum-True-int-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-True-sum-True-int-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-True-sum-True-float32-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-True-sum-True-float32-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-True-sum-True-bool_-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-True-sum-True-bool_-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-True-min-False-float-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-True-min-False-float-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-True-min-False-int-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-True-min-False-int-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-True-min-False-float32-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-True-min-False-float32-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-True-min-False-bool_-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-True-min-False-bool_-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-True-min-True-float-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-True-min-True-float-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-True-min-True-int-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-True-min-True-int-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-True-min-True-float32-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-True-min-True-float32-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-True-min-True-bool_-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-True-min-True-bool_-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-True-max-False-float-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-True-max-False-float-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-True-max-False-int-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-True-max-False-int-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-True-max-False-float32-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-True-max-False-float32-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-True-max-False-bool_-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-True-max-False-bool_-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-True-max-True-float-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-True-max-True-float-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-True-max-True-int-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-True-max-True-int-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-True-max-True-float32-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-True-max-True-float32-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-True-max-True-bool_-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-True-max-True-bool_-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-True-mean-False-float-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-True-mean-False-float-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-True-mean-False-int-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-True-mean-False-int-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-True-mean-False-float32-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-True-mean-False-float32-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-True-mean-True-float-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-True-mean-True-float-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-True-mean-True-int-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-True-mean-True-int-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-True-mean-True-float32-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-True-mean-True-float32-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-True-var-False-float-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-True-var-False-float-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-True-var-False-int-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-True-var-False-int-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-True-var-False-float32-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-True-var-False-float32-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-True-var-False-bool_-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-True-var-False-bool_-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-True-var-True-float-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-True-var-True-float-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-True-var-True-int-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-True-var-True-int-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-True-var-True-float32-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-True-var-True-float32-2]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-True-var-True-bool_-1]
PASSED xarray/tests/test_duck_array_ops.py::test_reduce[x-True-var-True-bool_-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[x-False-min-False-False-float-1]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[x-False-min-False-False-float-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[x-False-min-False-False-int-1]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[x-False-min-False-False-int-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[x-False-min-False-False-float32-1]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[x-False-min-False-False-float32-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[x-False-min-False-False-bool_-1]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[x-False-min-False-False-bool_-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[x-False-min-False-False-str-1]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[x-False-min-False-False-str-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[x-False-min-True-False-float-1]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[x-False-min-True-False-float-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[x-False-min-True-False-int-1]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[x-False-min-True-False-int-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[x-False-min-True-False-float32-1]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[x-False-min-True-False-float32-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[x-False-min-True-False-bool_-1]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[x-False-min-True-False-bool_-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[x-False-min-True-False-str-1]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[x-False-min-True-False-str-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[x-False-max-False-False-float-1]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[x-False-max-False-False-float-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[x-False-max-False-False-int-1]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[x-False-max-False-False-int-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[x-False-max-False-False-float32-1]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[x-False-max-False-False-float32-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[x-False-max-False-False-bool_-1]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[x-False-max-False-False-bool_-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[x-False-max-False-False-str-1]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[x-False-max-False-False-str-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[x-False-max-True-False-float-1]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[x-False-max-True-False-float-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[x-False-max-True-False-int-1]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[x-False-max-True-False-int-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[x-False-max-True-False-float32-1]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[x-False-max-True-False-float32-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[x-False-max-True-False-bool_-1]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[x-False-max-True-False-bool_-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[x-False-max-True-False-str-1]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[x-False-max-True-False-str-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[x-True-min-False-True-bool_-1]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[x-True-min-False-True-bool_-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[x-True-min-False-True-str-1]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[x-True-min-False-True-str-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[x-True-min-False-False-float-1]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[x-True-min-False-False-float-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[x-True-min-False-False-int-1]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[x-True-min-False-False-int-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[x-True-min-False-False-float32-1]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[x-True-min-False-False-float32-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[x-True-min-False-False-bool_-1]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[x-True-min-False-False-bool_-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[x-True-min-False-False-str-1]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[x-True-min-False-False-str-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[x-True-min-True-True-bool_-1]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[x-True-min-True-True-bool_-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[x-True-min-True-True-str-1]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[x-True-min-True-True-str-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[x-True-min-True-False-float-1]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[x-True-min-True-False-float-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[x-True-min-True-False-int-1]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[x-True-min-True-False-int-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[x-True-min-True-False-float32-1]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[x-True-min-True-False-float32-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[x-True-min-True-False-bool_-1]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[x-True-min-True-False-bool_-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[x-True-min-True-False-str-1]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[x-True-min-True-False-str-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[x-True-max-False-True-bool_-1]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[x-True-max-False-True-bool_-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[x-True-max-False-True-str-1]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[x-True-max-False-True-str-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[x-True-max-False-False-float-1]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[x-True-max-False-False-float-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[x-True-max-False-False-int-1]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[x-True-max-False-False-int-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[x-True-max-False-False-float32-1]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[x-True-max-False-False-float32-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[x-True-max-False-False-bool_-1]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[x-True-max-False-False-bool_-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[x-True-max-False-False-str-1]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[x-True-max-False-False-str-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[x-True-max-True-True-bool_-1]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[x-True-max-True-True-bool_-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[x-True-max-True-True-str-1]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[x-True-max-True-True-str-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[x-True-max-True-False-float-1]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[x-True-max-True-False-float-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[x-True-max-True-False-int-1]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[x-True-max-True-False-int-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[x-True-max-True-False-float32-1]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[x-True-max-True-False-float32-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[x-True-max-True-False-bool_-1]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[x-True-max-True-False-bool_-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[x-True-max-True-False-str-1]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[x-True-max-True-False-str-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[y-False-min-False-False-float-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[y-False-min-False-False-int-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[y-False-min-False-False-float32-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[y-False-min-False-False-bool_-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[y-False-min-False-False-str-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[y-False-min-True-False-float-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[y-False-min-True-False-int-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[y-False-min-True-False-float32-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[y-False-min-True-False-bool_-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[y-False-min-True-False-str-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[y-False-max-False-False-float-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[y-False-max-False-False-int-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[y-False-max-False-False-float32-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[y-False-max-False-False-bool_-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[y-False-max-False-False-str-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[y-False-max-True-False-float-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[y-False-max-True-False-int-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[y-False-max-True-False-float32-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[y-False-max-True-False-bool_-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[y-False-max-True-False-str-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[y-True-min-False-True-bool_-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[y-True-min-False-True-str-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[y-True-min-False-False-float-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[y-True-min-False-False-int-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[y-True-min-False-False-float32-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[y-True-min-False-False-bool_-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[y-True-min-False-False-str-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[y-True-min-True-True-bool_-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[y-True-min-True-True-str-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[y-True-min-True-False-float-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[y-True-min-True-False-int-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[y-True-min-True-False-float32-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[y-True-min-True-False-bool_-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[y-True-min-True-False-str-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[y-True-max-False-True-bool_-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[y-True-max-False-True-str-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[y-True-max-False-False-float-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[y-True-max-False-False-int-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[y-True-max-False-False-float32-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[y-True-max-False-False-bool_-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[y-True-max-False-False-str-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[y-True-max-True-True-bool_-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[y-True-max-True-True-str-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[y-True-max-True-False-float-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[y-True-max-True-False-int-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[y-True-max-True-False-float32-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[y-True-max-True-False-bool_-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max[y-True-max-True-False-str-2]
PASSED xarray/tests/test_duck_array_ops.py::test_argmin_max_error
PASSED xarray/tests/test_duck_array_ops.py::test_isnull[array0]
PASSED xarray/tests/test_duck_array_ops.py::test_isnull[array1]
PASSED xarray/tests/test_duck_array_ops.py::test_isnull[array2]
PASSED xarray/tests/test_duck_array_ops.py::test_isnull[array3]
PASSED xarray/tests/test_duck_array_ops.py::test_isnull[array4]
PASSED xarray/tests/test_duck_array_ops.py::test_isnull_with_dask
PASSED xarray/tests/test_duck_array_ops.py::test_dask_rolling[True-3-0]
PASSED xarray/tests/test_duck_array_ops.py::test_dask_rolling[True-3--1]
PASSED xarray/tests/test_duck_array_ops.py::test_dask_rolling[True-8-0]
PASSED xarray/tests/test_duck_array_ops.py::test_dask_rolling[True-8--1]
PASSED xarray/tests/test_duck_array_ops.py::test_dask_rolling[True-11-0]
PASSED xarray/tests/test_duck_array_ops.py::test_dask_rolling[True-11--1]
PASSED xarray/tests/test_duck_array_ops.py::test_dask_rolling[False-3-0]
PASSED xarray/tests/test_duck_array_ops.py::test_dask_rolling[False-3--1]
PASSED xarray/tests/test_duck_array_ops.py::test_dask_rolling[False-8-0]
PASSED xarray/tests/test_duck_array_ops.py::test_dask_rolling[False-8--1]
PASSED xarray/tests/test_duck_array_ops.py::test_dask_rolling[False-11-0]
PASSED xarray/tests/test_duck_array_ops.py::test_dask_rolling[False-11--1]
PASSED xarray/tests/test_duck_array_ops.py::test_dask_gradient[1-0]
PASSED xarray/tests/test_duck_array_ops.py::test_dask_gradient[1--1]
PASSED xarray/tests/test_duck_array_ops.py::test_dask_gradient[1-1]
PASSED xarray/tests/test_duck_array_ops.py::test_dask_gradient[2-0]
PASSED xarray/tests/test_duck_array_ops.py::test_dask_gradient[2--1]
PASSED xarray/tests/test_duck_array_ops.py::test_dask_gradient[2-1]
PASSED xarray/tests/test_duck_array_ops.py::test_min_count[None-prod-False-float-1]
PASSED xarray/tests/test_duck_array_ops.py::test_min_count[None-prod-False-float-2]
PASSED xarray/tests/test_duck_array_ops.py::test_min_count[None-prod-False-int-1]
PASSED xarray/tests/test_duck_array_ops.py::test_min_count[None-prod-False-int-2]
PASSED xarray/tests/test_duck_array_ops.py::test_min_count[None-prod-False-float32-1]
PASSED xarray/tests/test_duck_array_ops.py::test_min_count[None-prod-False-float32-2]
PASSED xarray/tests/test_duck_array_ops.py::test_min_count[None-prod-False-bool_-1]
PASSED xarray/tests/test_duck_array_ops.py::test_min_count[None-prod-False-bool_-2]
PASSED xarray/tests/test_duck_array_ops.py::test_min_count[None-prod-True-float-1]
PASSED xarray/tests/test_duck_array_ops.py::test_min_count[None-prod-True-float-2]
PASSED xarray/tests/test_duck_array_ops.py::test_min_count[None-prod-True-int-1]
PASSED xarray/tests/test_duck_array_ops.py::test_min_count[None-prod-True-int-2]
PASSED xarray/tests/test_duck_array_ops.py::test_min_count[None-prod-True-float32-1]
PASSED xarray/tests/test_duck_array_ops.py::test_min_count[None-prod-True-float32-2]
PASSED xarray/tests/test_duck_array_ops.py::test_min_count[None-prod-True-bool_-1]
PASSED xarray/tests/test_duck_array_ops.py::test_min_count[None-prod-True-bool_-2]
PASSED xarray/tests/test_duck_array_ops.py::test_min_count[x-prod-False-float-1]
PASSED xarray/tests/test_duck_array_ops.py::test_min_count[x-prod-False-float-2]
PASSED xarray/tests/test_duck_array_ops.py::test_min_count[x-prod-False-int-1]
PASSED xarray/tests/test_duck_array_ops.py::test_min_count[x-prod-False-int-2]
PASSED xarray/tests/test_duck_array_ops.py::test_min_count[x-prod-False-float32-1]
PASSED xarray/tests/test_duck_array_ops.py::test_min_count[x-prod-False-float32-2]
PASSED xarray/tests/test_duck_array_ops.py::test_min_count[x-prod-False-bool_-1]
PASSED xarray/tests/test_duck_array_ops.py::test_min_count[x-prod-False-bool_-2]
PASSED xarray/tests/test_duck_array_ops.py::test_min_count[x-prod-True-float-1]
PASSED xarray/tests/test_duck_array_ops.py::test_min_count[x-prod-True-float-2]
PASSED xarray/tests/test_duck_array_ops.py::test_min_count[x-prod-True-int-1]
PASSED xarray/tests/test_duck_array_ops.py::test_min_count[x-prod-True-int-2]
PASSED xarray/tests/test_duck_array_ops.py::test_min_count[x-prod-True-float32-1]
PASSED xarray/tests/test_duck_array_ops.py::test_min_count[x-prod-True-float32-2]
PASSED xarray/tests/test_duck_array_ops.py::test_min_count[x-prod-True-bool_-1]
PASSED xarray/tests/test_duck_array_ops.py::test_min_count[x-prod-True-bool_-2]
PASSED xarray/tests/test_duck_array_ops.py::test_min_count_dataset[prod]
PASSED xarray/tests/test_duck_array_ops.py::test_multiple_dims[sum-False-False-float]
PASSED xarray/tests/test_duck_array_ops.py::test_multiple_dims[sum-False-False-int]
PASSED xarray/tests/test_duck_array_ops.py::test_multiple_dims[sum-False-False-float32]
PASSED xarray/tests/test_duck_array_ops.py::test_multiple_dims[sum-False-False-bool_]
PASSED xarray/tests/test_duck_array_ops.py::test_multiple_dims[sum-False-True-float]
PASSED xarray/tests/test_duck_array_ops.py::test_multiple_dims[sum-False-True-int]
PASSED xarray/tests/test_duck_array_ops.py::test_multiple_dims[sum-False-True-float32]
PASSED xarray/tests/test_duck_array_ops.py::test_multiple_dims[sum-False-True-bool_]
PASSED xarray/tests/test_duck_array_ops.py::test_multiple_dims[sum-True-False-float]
PASSED xarray/tests/test_duck_array_ops.py::test_multiple_dims[sum-True-False-int]
PASSED xarray/tests/test_duck_array_ops.py::test_multiple_dims[sum-True-False-float32]
PASSED xarray/tests/test_duck_array_ops.py::test_multiple_dims[sum-True-False-bool_]
PASSED xarray/tests/test_duck_array_ops.py::test_multiple_dims[sum-True-True-float]
PASSED xarray/tests/test_duck_array_ops.py::test_multiple_dims[sum-True-True-int]
PASSED xarray/tests/test_duck_array_ops.py::test_multiple_dims[sum-True-True-float32]
PASSED xarray/tests/test_duck_array_ops.py::test_multiple_dims[sum-True-True-bool_]
PASSED xarray/tests/test_duck_array_ops.py::test_multiple_dims[prod-False-False-float]
PASSED xarray/tests/test_duck_array_ops.py::test_multiple_dims[prod-False-False-int]
PASSED xarray/tests/test_duck_array_ops.py::test_multiple_dims[prod-False-False-float32]
PASSED xarray/tests/test_duck_array_ops.py::test_multiple_dims[prod-False-False-bool_]
PASSED xarray/tests/test_duck_array_ops.py::test_multiple_dims[prod-False-True-float]
PASSED xarray/tests/test_duck_array_ops.py::test_multiple_dims[prod-False-True-int]
PASSED xarray/tests/test_duck_array_ops.py::test_multiple_dims[prod-False-True-float32]
PASSED xarray/tests/test_duck_array_ops.py::test_multiple_dims[prod-False-True-bool_]
PASSED xarray/tests/test_duck_array_ops.py::test_multiple_dims[prod-True-False-float]
PASSED xarray/tests/test_duck_array_ops.py::test_multiple_dims[prod-True-False-int]
PASSED xarray/tests/test_duck_array_ops.py::test_multiple_dims[prod-True-False-float32]
PASSED xarray/tests/test_duck_array_ops.py::test_multiple_dims[prod-True-False-bool_]
PASSED xarray/tests/test_duck_array_ops.py::test_multiple_dims[prod-True-True-float]
PASSED xarray/tests/test_duck_array_ops.py::test_multiple_dims[prod-True-True-int]
PASSED xarray/tests/test_duck_array_ops.py::test_multiple_dims[prod-True-True-float32]
PASSED xarray/tests/test_duck_array_ops.py::test_multiple_dims[prod-True-True-bool_]
PASSED xarray/tests/test_duck_array_ops.py::test_docs
PASSED xarray/tests/test_duck_array_ops.py::test_datetime_to_numeric_datetime64
PASSED xarray/tests/test_duck_array_ops.py::test_datetime_to_numeric_cftime
PASSED xarray/tests/test_duck_array_ops.py::test_datetime_to_numeric_potential_overflow
PASSED xarray/tests/test_duck_array_ops.py::test_py_timedelta_to_float
PASSED xarray/tests/test_duck_array_ops.py::test_np_timedelta64_to_float[td0-86400000000000.0]
PASSED xarray/tests/test_duck_array_ops.py::test_np_timedelta64_to_float[td1-1.0]
PASSED xarray/tests/test_duck_array_ops.py::test_pd_timedelta_to_float[td0-86400000000000.0]
PASSED xarray/tests/test_duck_array_ops.py::test_pd_timedelta_to_float[td1-1.0]
PASSED xarray/tests/test_duck_array_ops.py::test_timedelta_to_numeric[td0]
PASSED xarray/tests/test_duck_array_ops.py::test_timedelta_to_numeric[td1]
PASSED xarray/tests/test_duck_array_ops.py::test_timedelta_to_numeric[td2]
PASSED xarray/tests/test_duck_array_ops.py::test_timedelta_to_numeric[1 day]
PASSED xarray/tests/test_duck_array_ops.py::test_least_squares[True-True]
PASSED xarray/tests/test_duck_array_ops.py::test_least_squares[True-False]
PASSED xarray/tests/test_duck_array_ops.py::test_least_squares[False-True]
PASSED xarray/tests/test_duck_array_ops.py::test_least_squares[False-False]
SKIPPED [16] xarray/tests/test_duck_array_ops.py:398: dask does not compute object-typed array
SKIPPED [16] xarray/tests/test_duck_array_ops.py:392: numpy does not support this
SKIPPED [60] xarray/tests/test_duck_array_ops.py:487: numpy's argmin (not nanargmin) does not handle object-dtype
SKIPPED [36] xarray/tests/test_duck_array_ops.py:491: numpy's nanargmin raises ValueError for all nan axis
SKIPPED [80] xarray/tests/test_duck_array_ops.py:480: dim not in this test
FAILED xarray/tests/test_duck_array_ops.py::test_min_count[None-sum-False-float-1]
FAILED xarray/tests/test_duck_array_ops.py::test_min_count[None-sum-False-float-2]
FAILED xarray/tests/test_duck_array_ops.py::test_min_count[None-sum-False-int-1]
FAILED xarray/tests/test_duck_array_ops.py::test_min_count[None-sum-False-int-2]
FAILED xarray/tests/test_duck_array_ops.py::test_min_count[None-sum-False-float32-1]
FAILED xarray/tests/test_duck_array_ops.py::test_min_count[None-sum-False-float32-2]
FAILED xarray/tests/test_duck_array_ops.py::test_min_count[None-sum-False-bool_-1]
FAILED xarray/tests/test_duck_array_ops.py::test_min_count[None-sum-False-bool_-2]
FAILED xarray/tests/test_duck_array_ops.py::test_min_count[None-sum-True-float-1]
FAILED xarray/tests/test_duck_array_ops.py::test_min_count[None-sum-True-float-2]
FAILED xarray/tests/test_duck_array_ops.py::test_min_count[None-sum-True-int-1]
FAILED xarray/tests/test_duck_array_ops.py::test_min_count[None-sum-True-int-2]
FAILED xarray/tests/test_duck_array_ops.py::test_min_count[None-sum-True-float32-1]
FAILED xarray/tests/test_duck_array_ops.py::test_min_count[None-sum-True-float32-2]
FAILED xarray/tests/test_duck_array_ops.py::test_min_count[None-sum-True-bool_-1]
FAILED xarray/tests/test_duck_array_ops.py::test_min_count[None-sum-True-bool_-2]
FAILED xarray/tests/test_duck_array_ops.py::test_min_count[x-sum-False-float-1]
FAILED xarray/tests/test_duck_array_ops.py::test_min_count[x-sum-False-float-2]
FAILED xarray/tests/test_duck_array_ops.py::test_min_count[x-sum-False-int-1]
FAILED xarray/tests/test_duck_array_ops.py::test_min_count[x-sum-False-int-2]
FAILED xarray/tests/test_duck_array_ops.py::test_min_count[x-sum-False-float32-1]
FAILED xarray/tests/test_duck_array_ops.py::test_min_count[x-sum-False-float32-2]
FAILED xarray/tests/test_duck_array_ops.py::test_min_count[x-sum-False-bool_-1]
FAILED xarray/tests/test_duck_array_ops.py::test_min_count[x-sum-False-bool_-2]
FAILED xarray/tests/test_duck_array_ops.py::test_min_count[x-sum-True-float-1]
FAILED xarray/tests/test_duck_array_ops.py::test_min_count[x-sum-True-float-2]
FAILED xarray/tests/test_duck_array_ops.py::test_min_count[x-sum-True-int-1]
FAILED xarray/tests/test_duck_array_ops.py::test_min_count[x-sum-True-int-2]
FAILED xarray/tests/test_duck_array_ops.py::test_min_count[x-sum-True-float32-1]
FAILED xarray/tests/test_duck_array_ops.py::test_min_count[x-sum-True-float32-2]
FAILED xarray/tests/test_duck_array_ops.py::test_min_count[x-sum-True-bool_-1]
FAILED xarray/tests/test_duck_array_ops.py::test_min_count[x-sum-True-bool_-2]
FAILED xarray/tests/test_duck_array_ops.py::test_min_count_nd[sum-False-float]
FAILED xarray/tests/test_duck_array_ops.py::test_min_count_nd[sum-False-int]
FAILED xarray/tests/test_duck_array_ops.py::test_min_count_nd[sum-False-float32]
FAILED xarray/tests/test_duck_array_ops.py::test_min_count_nd[sum-False-bool_]
FAILED xarray/tests/test_duck_array_ops.py::test_min_count_nd[sum-True-float]
FAILED xarray/tests/test_duck_array_ops.py::test_min_count_nd[sum-True-int]
FAILED xarray/tests/test_duck_array_ops.py::test_min_count_nd[sum-True-float32]
FAILED xarray/tests/test_duck_array_ops.py::test_min_count_nd[sum-True-bool_]
FAILED xarray/tests/test_duck_array_ops.py::test_min_count_nd[prod-False-float]
FAILED xarray/tests/test_duck_array_ops.py::test_min_count_nd[prod-False-int]
FAILED xarray/tests/test_duck_array_ops.py::test_min_count_nd[prod-False-float32]
FAILED xarray/tests/test_duck_array_ops.py::test_min_count_nd[prod-False-bool_]
FAILED xarray/tests/test_duck_array_ops.py::test_min_count_nd[prod-True-float]
FAILED xarray/tests/test_duck_array_ops.py::test_min_count_nd[prod-True-int]
FAILED xarray/tests/test_duck_array_ops.py::test_min_count_nd[prod-True-float32]
FAILED xarray/tests/test_duck_array_ops.py::test_min_count_nd[prod-True-bool_]
FAILED xarray/tests/test_duck_array_ops.py::test_min_count_dataset[sum] - Typ...
========== 49 failed, 563 passed, 208 skipped, 21 warnings in 11.53s ===========
>>>>> End Test Output
SWEBENCH_TEST_EXIT_CODE=1
