```python
### xarray/core/duck_array_ops.py
<<<<<<< SEARCH
def timedelta_to_numeric(value, datetime_unit="ns", dtype=float):
    """Convert a timedelta-like object to numerical values.

    Parameters
    ----------
    value : datetime.timedelta, numpy.timedelta64, pandas.Timedelta, str
        Time delta representation.
    datetime_unit : {Y, M, W, D, h, m, s, ms, us, ns, ps, fs, as}
        The time units of the output values. Note that some conversions are not allowed due to
        non-linear relationships between units.
    dtype : type
        The output data type.

    """
    import datetime as dt

    if isinstance(value, dt.timedelta):
        out = py_timedelta_to_float(value, datetime_unit)
    elif isinstance(value, np.timedelta64):
        out = np_timedelta64_to_float(value, datetime_unit)
    elif isinstance(value, pd.Timedelta):
        out = pd_timedelta_to_float(value, datetime_unit)
    elif isinstance(value, str):
        try:
            a = pd.to_timedelta(value)
        except ValueError:
            raise ValueError(
                f"Could not convert {value!r} to timedelta64 using pandas.to_timedelta"
            )
        return py_timedelta_to_float(a, datetime_unit)
    else:
        raise TypeError(
            f"Expected value of type str, pandas.Timedelta, datetime.timedelta "
            f"or numpy.timedelta64, but received {type(value).__name__}"
        )
    return out.astype(dtype)
=======
def timedelta_to_numeric(value, datetime_unit="ns", dtype=float):
    """Convert a timedelta-like object to numerical values.

    Parameters
    ----------
    value : datetime.timedelta, numpy.timedelta64, pandas.Timedelta, str
        Time delta representation.
    datetime_unit : {Y, M, W, D, h, m, s, ms, us, ns, ps, fs, as}
        The time units of the output values. Note that some conversions are not allowed due to
        non-linear relationships between units.
    dtype : type
        The output data type.

    """
    import datetime as dt

    if isinstance(value, dt.timedelta):
        out = py_timedelta_to_float(value, datetime_unit)
    elif isinstance(value, np.timedelta64):
        out = np_timedelta64_to_float(value, datetime_unit)
    elif isinstance(value, pd.Timedelta):
        out = pd_timedelta_to_float(value, datetime_unit)
    elif isinstance(value, str):
        try:
            a = pd.to_timedelta(value)
        except ValueError:
            raise ValueError(
                f"Could not convert {value!r} to timedelta64 using pandas.to_timedelta"
            )
        return py_timedelta_to_float(a, datetime_unit)
    else:
        raise TypeError(
            f"Expected value of type str, pandas.Timedelta, datetime.timedelta "
            f"or numpy.timedelta64, but received {type(value).__name__}"
        )
    return out.astype(dtype, copy=False)
>>>>>>> REPLACE
```

This change ensures that the conversion from `np.timedelta64` to a numerical value does not create a copy of the array, which can help avoid potential issues with memory and performance. However, the primary issue seems to be related to the handling of `np.timedelta64` in the `polyval` function. Let's also ensure that the `polyval` function correctly handles `timedelta64` coordinates.

```python
### xarray/core/computation.py
<<<<<<< SEARCH
@overload
def polyval(coord: DataArray, coeffs: DataArray, degree_dim: Hashable) -> DataArray:
    ...


@overload
def polyval(coord: DataArray, coeffs: Dataset, degree_dim: Hashable) -> Dataset:
    ...


@overload
def polyval(coord: Dataset, coeffs: DataArray, degree_dim: Hashable) -> Dataset:
    ...
...
def polyval(coord, coeffs, degree_dim):
    """Evaluate polynomial at specific points.

    Parameters
    ----------
    coord : DataArray or Dataset
        The coordinates at which to evaluate the polynomial.
    coeffs : DataArray or Dataset
        The coefficients of the polynomial.
    degree_dim : Hashable
        The dimension along which the polynomial degrees are stored.

    Returns
    -------
    DataArray or Dataset
        The evaluated polynomial.
    """
    if isinstance(coord, Dataset):
        return coord.map(lambda x: polyval(x, coeffs, degree_dim))
    if isinstance(coeffs, Dataset):
        return coeffs.map(lambda x: polyval(coord, x, degree_dim))

    # Ensure coord is a DataArray
    coord = as_dataarray(coord)

    # Ensure degree_dim is a string
    degree_dim = str(degree_dim)

    # Ensure the degree dimension is present in the coefficients
    if degree_dim not in coeffs.dims