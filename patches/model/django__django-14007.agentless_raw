```python
### django/db/models/sql/compiler.py
<<<<<<< SEARCH
            if self.connection.features.can_return_columns_from_insert:
                assert len(self.query.objs) == 1
                return [self.connection.ops.fetch_returned_insert_columns(cursor, self.returning_params)]
            return [(self.connection.ops.last_insert_id(
                cursor, self.query.get_meta().db_table, self.query.get_meta().pk.column
            ),)]
=======
            if self.connection.features.can_return_columns_from_insert:
                assert len(self.query.objs) == 1
                row = self.connection.ops.fetch_returned_insert_columns(cursor, self.returning_params)
                if row:
                    row = [self.query.get_meta().pk.from_db_value(val, self.query.get_meta().pk, self.connection) for val in row]
                return [row]
            return [(self.connection.ops.last_insert_id(
                cursor, self.query.get_meta().db_table, self.query.get_meta().pk.column
            ),)]
>>>>>>> REPLACE
```

This *SEARCH/REPLACE* edit ensures that the `from_db_value` method is called on the primary key field when the row is fetched after an insert operation. This addresses the issue where the returned integer is not passed through the database converters defined for the field.