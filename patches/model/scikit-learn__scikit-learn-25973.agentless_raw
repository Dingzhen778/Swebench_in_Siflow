```python
### sklearn/feature_selection/_sequential.py
<<<<<<< SEARCH
        cloned_estimator = clone(self.estimator)

        # the current mask corresponds to the set of features:
        # - that we have already *selected* if we do forward selection
        # - that we have already *excluded* if we do backward selection
        current_mask = np.zeros(shape=n_features, dtype=bool)
        n_iterations = (
            self.n_features_to_select_
            if self.n_features_to_select == "auto" or self.direction == "forward"
            else n_features - self.n_features_to_select_
        )

        old_score = -np.inf
        is_auto_select = self.tol is not None and self.n_features_to_select == "auto"
        for _ in range(n_iterations):
            new_feature_idx, new_score = self._get_best_new_feature_score(
                cloned_estimator, X, y, current_mask
            )
            if is_auto_select and ((new_score - old_score) < self.tol):
                break

            old_score = new_score
            current_mask[new_feature_idx] = True
=======
        cloned_estimator = clone(self.estimator)

        # the current mask corresponds to the set of features:
        # - that we have already *selected* if we do forward selection
        # - that we have already *excluded* if we do backward selection
        current_mask = np.zeros(shape=n_features, dtype=bool)
        n_iterations = (
            self.n_features_to_select_
            if self.n_features_to_select == "auto" or self.direction == "forward"
            else n_features - self.n_features_to_select_
        )

        old_score = -np.inf
        is_auto_select = self.tol is not None and self.n_features_to_select == "auto"
        for _ in range(n_iterations):
            new_feature_idx, new_score = self._get_best_new_feature_score(
                cloned_estimator, X, y, current_mask, cv=self.cv
            )
            if is_auto_select and ((new_score - old_score) < self.tol):
                break

            old_score = new_score
            current_mask[new_feature_idx] = True
>>>>>>> REPLACE
```

```python
### sklearn/feature_selection/_sequential.py
<<<<<<< SEARCH
    def _get_best_new_feature_score(self, estimator, X, y, current_mask):
        # Return the best new feature and its score to add to the current_mask,
        # i.e. return the best new feature and its score to add (resp. remove)
        # when doing forward selection (resp. backward selection).
        # Feature will be added if the current score and past score are greater
        # than tol when n_feature is auto,
        candidate_feature_indices = np.flatnonzero(~current_mask)
        scores = {}
        for feature_idx in candidate_feature_indices:
=======
    def _get_best_new_feature_score(self, estimator, X, y, current_mask, cv=None):
        # Return the best new feature and its score to add to the current_mask,
        # i.e. return the best new feature and its score to add (resp. remove)
        # when doing forward selection (resp. backward selection).
        # Feature will be added if the current score and past score are greater
        # than tol when n_feature is auto,
        candidate_feature_indices = np.flatnonzero(~current_mask)
        scores = {}
        for feature_idx in candidate_feature_indices:
            if cv is not None:
                cv_splits = list(cv)
            else:
                cv_splits = None

            # Perform cross-validation to get the score for the current feature
            feature_scores = []
            for train_index, test_index in cv_splits:
                X_train, X_test = X[train_index], X[test_index]
                y_train, y_test = y[train_index], y[test_index]

                # Fit the estimator with the current feature
                X_train_with_feature = np.hstack((X_train[:, current_mask], X_train[:, [feature_idx]]))
                X_test_with_feature = np.hstack((X_test[:, current_mask], X_test[:, [feature_idx]]))

                estimator.fit(X_train_with_feature, y_train)
                score = estimator.score(X_test_with_feature, y_test)
                feature_scores.append(score)

            scores[feature_idx] = np.mean(feature_scores)

        best_feature_idx = max(scores, key=scores.get)
        best_score = scores[best_feature_idx]

        return best_feature_idx, best_score
>>>>>>> REPLACE
```